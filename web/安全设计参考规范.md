---
layout: default
title: 安全设计参考规范
---
# 业务系统安全设计简述

应用安全设计主要针对于应用软件的架构设计阶段，帮助开发项目的架构设计人员完成安全功能的设计，并最终保证应用在开发设计层面的整体安全性


## 目的介绍

在设计初始阶段，应该使用可靠的体系结构和设计方法，同时要结合考虑程序部署以及企业的安全策略。

本规范提供了关于业务系统安全设计的要求，并按照常见的应用程序漏洞类别进行组织。这些规范是应用程序安全的重要要求，并且也是应用程序经常发生错误的方面。

通过将安全需求文档提出的业务安全需求转换到架构安全设计中，并且提出建设性建议来指导和保护用户关键信息资产。

## 	使用对象

本规范的读者及使用对象主要为相关的设计人员，项目相关的安全需求人员、开发人员、安全测试人员也可查阅。

## 实现目标

1. 确定安全应用程序的重要体系结构和设计问题。
2. 制定能增强应用程序输入验证的策略。
3. 设计安全的身份验证和会话管理机制。
4. 实现有效的帐户管理方法，并保护用户会话。
5. 对隐私、认可、防止篡改和身份验证信息进行加密。
6. 防止参数操作。
7. 设计审核和记录策略。


# 应用程序通用安全设计

## 服务端应用程序通用安全设计

### 输入输出验证

输入应用程序安全防范的首道防线。如果不能让恶意的数据进入的程序，那么至少应该不在程序中处理它，你的程序在面对攻击时将更加健壮。这与防火墙保护计算机的原理很类似；它不能预防所有的攻击，但它可以让一个程序更加稳定。这个过程叫做检查、验证或者过滤输入。

### 输入验证步骤

应用软件针对所有进入数据的验证过程有如下三个处理方法，对于不符合输入要求的数据则丢弃:

1. 限制输入

    这是首选的输入验证方法，也是最重要的检查手段。定义一个筛选器，根据类型、长度、格式和范围筛选输入的数据，可使用正则表达式验证比较简单的数据输入，以下是对几种输入数据的处理方法：
    + 数据类型
        例如：接入的数字一定是数字型，则只接受数字型的字符串输入，但要预料到可能接收到字母或特殊符号的输入，例如在java中，用户输入一个浮点类型的数据提交给服务端运算，可能出现很糟糕的情况。
    + 长度
        必须预料到用户输入超长的数据，以防止恶意用户精心构造超过一定长度的攻击语句，例如SQL注入攻击、缓冲区溢出等。
    + 格式
        一般情况为了提高用户体检，在客户端使用脚本检查用户是不是误操作输入，但服务端要预料到客户端检查脚本失效的情况，例如针对身份证、邮箱的检测。
    + 范围
        很明显的，如果在一个交易系统中，没有对用户输入的交易数量进行检查，恶意的用户输入一个数值为负的结果，可能出现一个难以查觉的业务错误

2. 拒绝输入

    拒绝输入也是大众所理解的黑名单模式，它不能作为输入的主要检查手段，有效的数据格式是保持不变的，但有害的数据范围无法预料，它可以作为”限制输入”的辅助验证手段，使得验证输入功能更加可靠。
    在限制了用户输入后，仍然有一些恶意输入通过限制输入进入应用软件，建议使用已知的恶意输入来拒绝用户的输入。例如注册应用帐号时使用”system”、”系统管理员”等，不仅可利用欺骗用户，也可能利用攻击应用软件。

3. 净化输入

    净化输入为了使潜在危害的变得安全，如果所允许的输入不能保证输入数据的安全性，那么接下来应该净化用户的输入，剔除某些字符可以加强应用软件安全。例如在应用程序审计功能中可能需要将用户的输入写入日志，如果用户输入\n，可能导致日志记录换行，净化输入处理应该包含以下字符串：
    + 空字节(%00)；
    + `<>"' %()& +\\'\"`
    + 验证换行符(%0d,%0a,\r,\n)；
    + 验证路径替代字符“点-点-斜杠”（../或..\）。如果支持UTF-8扩展字符集编码，验证替代字符：%c0%ae%c0%ae/(使用标准化验证双编码或其他类型的编码攻击)

####	输入验证功能设计

+ 定义应用软件不信任的数据来源并且验证其输入，如用户提交的任何数据、外部系统提交的数据、内部应用程序自身产生的数据，定义所有接受数据输入的接口，了解这些数据接口接受何种数据输入，制定对应的验证规则验证所有数据源。
+ 使用集中验证方法：尽量使用共享库中的验证方法和筛选代码，确保验证规则一致性，减少开发工作量，便于后期的扩展升级，如果共享库不满足要求，可考虑使用框架功能、软件全局配置文件(例如java中的web.xml)来实现。
+ 明确软件恰当的字符集：对所有输入使用恰当的字符集，如UTF-8，如果选择UTF-8，应该先解码UTF-8，然后再验证。
+ 客户端验证与服务端验证：客户端验证是为了给用户更好的体检，也是为了防止或校正用户无恶意错误输入，但由于客户端是不受信任的对象，因此来源数据也不应该被信任，所以应该建立服务端验证机制。
+ 让程序为用户确定访问对象：如果用户需要访问受限制的对象(详情请参见4.4.2授权部分中的” 对下列资源进行访问授权控制”)，应该让应用程序根据用户会话权限确定访问对象
+ 建议采用白名单放弃黑名单：白名单包含允许内容的模式，黑名单包含不允许内容的模式，随着攻击手段的多变和更新，用黑名单通常没有办法定义所有的恶意内容，使用白名单法更安全和容易。

#### 验证所有不信任的输入

+ 验证客户端提交的所有数据，包括：所有参数、URL，如果需要验证协议头信息，应该在其他验证过程之前进行，并且不可以将协议头信息作为主要验证依据
+ 核实在请求和响应的头信息中只含有ASCII字符。
+ 验证数据范围和长度。
+ 如果任何潜在的危险字符必须被允许输入，必须确保存在额外的控制。例如净化输入、输出编码、安全API等。


#### 输出编码

应该所有输出到外部的内容进行编码或者过滤，最常见的是页面内取自于SQL查询结果、XML、LDAP等后端存储系统内的数据，这种格式的数据一般以HTML主体或属性的方式输出，但也可能来自JS、CSS等方式的输出，如果来自JS，尤其注意防止利用已存在的JS标签构造的XSS攻击。

#### 防范元字符攻击

所有的类似脚本语言以及标记语言之类的强调易用性与交互性的技术都有一个共性：其可以接受可变的控制结构与数据。
例如，SQL查询：`select*fromempwhere name='Brian'`，由`"select","from","where",and "=" with the data "*", "emp","name"以及"Brian"`这些关键字组合。
攻击者通常会使用具有特殊含义的字符或字符串来利用这些漏洞。例如在SQL中单引号是危险的字符。在命令shell中，分号比较危险。通过对同一段元字符的多种编码方式以及对同一种语言的多种实现方式，这个问题更加危险。

+ 使用正确的参数化SQL，防止SQL注入攻击。
+ 跨站脚本对尖括号和双引号等进行编码处理。
+ 路径操纵使用白名单限制正斜杠(/)、反斜杠(\)、小数点(.)的输入。
+ 命令注入使用白名单检测过滤表单参数值数据内容。
+ 日志欺骗使用(\n)字符串伪造换行。


### 认证和密码管理

#### 口令策略

+ 强制密码复杂度要求。例如必须包含字母、数字和特殊符号三类字符。
+ 强制密码长度要求。例如必须8位字符及以上。
+ 输入的密码应当在用户的屏幕上模糊显示。
+ 禁止新旧密码相同。
+ 用户名密码不能相同。
+ 如果采用双因素认证：使用手机短信或动态令牌双因素认证，应该设置口令的最长有限时间，同时限制生成口令的间隔最短时间。


#### 认证失败处理

+ 设置某一时间段内无效登录次数的值（常见5次），强制执行账户失效，锁定后可由系统维护人员解锁，或者一定时间后自动解锁，锁定的时间应该足够长，但不能长到允许执行拒绝服务攻击。
+ 用户认证失败的提示应该模糊处理，可以使用“用户名或密码错误”，而不应该使用“用户不存在”或者“密码错误”。

#### 身份认证过程

身份鉴别功能是在计算机确认操作者身份的解决方法，对于计算机来说，任何身份鉴别信息都是一段字符串，计算机根据这段字符串来对用户授权。在应用软件中对用户的身份鉴别需求基本可分为以下三部分：
+ 标识和鉴别
    
    应支持用户标识和用户鉴别；在每一个用户注册到系统时，采用用户名和用户标识符标识用户身份，并确保在系统整个生存周期用户标识的唯一性；

+ 鉴别机制

    在每次用户登录和重新连接系统时，采用受安全管理中心控制的口令、基于生物特征的数据、数字证书以及其他具有相应安全强度的两种或两种以上的组合机制进行用户身份鉴别，且其中一种鉴别技术产生的鉴别数据是不可伪造的，其中如采用密码作为鉴别手段，可考虑主动提供密码长度、复杂度、定期修改以及失败登录次数限定等密码健壮度增强措施。投资者发出申购、赎回等重要操作，可考虑提供进一步的口令确认；
+ 鉴别数据保护

    对鉴别数据进行保密性和完整性保护。



1. 认证方式的选择

    用户身份鉴别强度选择应该依据重要的程度，对高价值、可能造成风险的操作使用高强度的身份鉴别

2. 验证必须在可信系统上进行

    包括HASH计算，避免向客户端透露更多的计算信息

3. 二次身份鉴别

    对高价值交易、系统和业务关键保护区域重新进行身份鉴别，如修改密码、业务交易的关键流程部分、系统关键配置部分。

4. 认证失败后的处理方式

    + 连续失败后锁定帐号：
        锁定后可由系统维护人员解锁，或者一定时间后自动解锁，锁定的时间应该足够长，但不能长到允许执行拒绝服务攻击。
    + 安全报错信息：
        用户认证失败的提示应该模糊处理，可以使用“用户名或密码错误”，而不应该使用“用户不存在”或者“密码错误”，并且提示信息与源代码中保持一致。

5. 口令策略

    + 口令强度：
        限制口令设置的最小长度，大小写字母、数字、特殊字符混淆的口令强度；
    + 双因素认证：
        如果使用手机短信或动态令牌双因素认证，应该设置口令的最长有限时间，同时限制生成口令的间隔最短时间。
6. 图片验证码
    图片验证码可以抵御自动识别软件的暴力登录攻击，图片验证过程应该由服务端进行，同时先验证图片验证码，再验证用户名和密码。图片验证码的实现应该最低4位，并且使用字符随机扭曲、字符颜色和背景色随机、字符随机倾斜、字符间距随机、大小随机等防自动识别的方法
7. 密码重设
    + 重设问题应该支持尽可能的随机，或者让用户选择重设问题；
    + 重置密码发送邮箱避免完整的显示给用户，如果对方是一个攻击者，那等于告诉人家去黑那个邮箱；
    + 如果将重置密码链接发送给用户邮箱，应该发送给预先注册的地址，同时重置关键字应该随机化，同时设置有效时间。重设后和临时密码在登录后应该强制用户修改密码；
    + 当密码重新设置时，应通知用户。


#### 验证码强度

+ 图片验证码可以抵御自动登录软件的暴力登录攻击，其应该具备以下安全要素：
    1. 图片验证码应该验证码长度至少4位。
    2. 使用字符随机扭曲、字符颜色和背景色随机、字符随机倾斜、字符间距随机、大小随机的技术手段防止自动识别。
    3. 验证过程应该由服端进行。
    4. 先验证图片验证码，再验证用户名和密码。

+ 每验证一次用户名和密码的组合，不论验证成功与否，应用删除当前校验码的会话，在下一次的验证重新生成图片验证码，避免重放攻击。
+ 校验码的实现和版本避免使用已知的漏洞版本。


#### 密码重置

+ 重设问题应该支持尽可能的随机，或者让用户选择重设问题；
+ 重置密码发送邮箱避免完整的显示给用户，如果对方是一个攻击者，那等于告诉人家去黑那个邮箱；
+ 如果将重置密码链接发送给用户邮箱，应该发送给预先注册的地址，同时重置关键字应该随机化，同时设置有效时间。重设后和临时密码在登录后应该强制用户修改密码；
+ 当密码重新设置时，应通知用户。


### 会话管理

会话管理技术是让服务端保持识别客户端访问身份的一种技术，会话安全是保障应用软件受限资源安全访问的关键所在，一般使用以下控制方法加强会话安全控制：

1. 会话标识在可信的系统上创建。
2. 会话生成应该使用足够强度的算法以保证足够随机，例如128位安全随机标识符。
3. 允许用户自行注销会话,登录后在任何页面上设置允许注销会话，并且彻底废弃此会话标识。
4. 会话标识双因素验证：验证会话标识的同时，验证其他可作为辅助验证身份的字符串，以防止会话标识符盗用。一般的会话标识符双因素验证分为以下两种种情况：
    
    + 会话标识符+硬件设备ID
        在某些B/S应用中(如ActiveX)，将会话标识与硬件ID绑定；如果是在C/S应用中，更容易实现。
    + 会话标识符+IP地址
        将登录IP与预设的COOKIE进行HASH运算，当发现访问IP变化时，清除会话标识符并要求用户重新登录，并且重新生成HASH值，在某些情况下（WAP应用）中，由于WAP的网关的存在，在服务器看来，访问者的IP地址都一样，所以可能不适用

5. 设置会话闲置时间
    为了防止用户忘记注销，应当限制会话闲置时间，根据会话允许的操作设置闲置时间，一般不超过30分钟。

6. 任何重新进行的身份鉴别中，建立一个新的会话标识符，而不要尝试给旧的会话标识符设定新的访问权限。

7. 不允许同一个用户并发登录。

8. 避免在敏感位置暴露会话标识符，如URL，错误信息或日志中，会话标识符只允许出现在HTTP头的COOKIE中。

9.  在以下条件下强制会话失效：

    + 客户端进程终止：如果客户端使用浏览器，并且使用cookie作会会话管理手段，则彻底清除cookie；
    + 会话访问来源IP变更：同一个会话标识，访问来源IP变更；
    + 一个会话在登录前已经建立，在此用户登录后，关闭会话并建立一个新的会话；
    + 在身份鉴别之时，访问链接从HTTP变为HTTPS，生成一个新的会话标识，一般情况下，不建议从HTTP与HTTPS中转换。

10.	如果使用cookie作为会话管理，考虑设置以下属性以加强其安全性:

    + DOMAIN：cookie生效域，非指定域名下此cookie不生效；
    + PATH：cookie生效路径，非指定路径下此cookie不生效；
    + SECURE：设置是否允许cookie在非SSL通道中传送，当会话过程通过SSL加密时，可启用此属性；
    + EXPIRES：设置cookie过期时间，在过期后，此cookie不再有效，在越是重要的功能中，生效时间越应该短；
    + HTTPONLY：设置是否允许cookie被脚本操控，除非在应用程序中明确要求客户端脚本程序读取或者设置cookie的值。这在对付使用XSS漏洞盗取cookie较为有效，但尤其要注意，XSS漏洞不仅仅只盗取cookie；
    + 不要将任何关键信息存储在Cookie中。例如，不要将用户的密码存储在Cookie中，即使是暂时存储也不要这样做。通常，不要将任何信息保存在Cookie中，因为一旦它被假冒，就会危及您的应用程序的安全。

11.	使用session作为会话管理：session存储在服务端，所以避免了客户端被盗的风险，由于session由服务端管理，因此在大量用户访问时可能会影响服务器性能，设定定时清除不活动的session是一个好办法。

### 权限管理

通过权限的管理，确定已通过验证的用户执行哪些操作或者访问哪些资源。错误的授权或弱授权会导致应用程序信息和用户敏感信息被非法访问或篡改。

+ 纵向越权：一个低权限的用户访问高权限用户的资源或功能。
+ 横向越权：用户尝试访问与其同级权限用户的资源或功能。



1. 创建基于角色的授权
    对系统资源创建基于角色授权的访问控制方法，同时对所有系统访问用户分析访问角色，当用户尝试访问受限制资源时，验证其角色。
2. 代码执行权限最小化
    用户不能做的事情，代码也不能做，以防止某些情况代码权限被滥用。
3. 可信授权认证
    使用可信系统对资源进行授权和验证。
4. 对下列资源进行访问授权控制:

    + 访问文件
    + 访问受保护的URL
    + 访问受保护的应用程序功能
    + 访问受保护的应用程序数据
    + 访问受保护的用户、数据属性和其策略信息
    + 访问受保护的访问控制策略
    + 任何服务端的数据创建行为，包括数据库内容创建、文件或文件夹创建

5. 保护存储在客户端的访问状态数据

    如果访问状态数据必须存储在客户端，使用加密算法，并在服务端检查完整性以防止状态改变；

6. 限制单位时间内事务请求数量

    限制单一用户或者外部数据请求在单位内可执行的事务请求数量，请求数量应该高于业务实际需求，但也应该足够抵御和判断自动化攻击，常见的如：获取某些状态数据、用户执行业务操作频率；

7. 使用协议头作为辅助检查手段

    常见的，如在HTTP协议下，referer头可以一定程度上作为辅助检查依据，但不应该作为主要检查依据，因为它可以被伪造；

8. 账户注销

    注销长时间不活动的帐户。


### 通信安全

一般可采用TLS:一般用于HTTP和FTP协议中，加密应用层和传输层数据，利用数据加密、身份验证和消息完整性验证机制，保证网络通信传输过程数据的安全性，需要注意的是，TLS使用的证书需要另外颁发，以下介绍了两种TLS证书的来源以及区别：

+ 建立证书服务自己给自己颁发，但默认不被浏览器信任，用户每次浏览网站的时候都会提示证书来源不可信。
+ 向可被浏览器信任的证书颁发机构购买证书，需要支付一定的费用，好处是用户访问网站时不会提示证书来源不可信，增加了用户体检。

不论使用哪种方面获取证书，加密和解密过程都依赖服务器的硬件资源，对于硬件资源比较窘迫的环境，可能不一定适合，这时可以选用专用的加密硬件来完成这部分工作，例如加密机，加密机有一套完善的密钥管理方案，包括密钥的生成、分配、贮存、转换、分工和分层，因此它的效率和安全性很高，目前在各个银行的网上交易系统中应用非常多。

针对加密协议的安全规则:

+ 客户端与服务器之间所有经过认证的连接都需要使用不低于TLS安全级别的加密通讯方式。
+ 使用TLS协议时，其版本应1.2及更高以上版本。
+ 使用TLS协议时，应取消对低版本TLS协议的支持

针对安全认证过程的安全规则:

+ 在通信双方建立连接之前，应利用密码技术进行会话初始化验证。
+ 应对通信过程中的整个报文或会话过程进行加密，例如采用HTTPS方式。
+ 系统应进行完整性校验，如SHA1。完整性校验码密钥长度不低于128位。
+ 使用TLS协议时，用于产生签名的RSA密钥长度不应低于1024位。
+ 使用TLS协议时，确保TLS证书使用正确的domain name。
+ 使用TLS协议时，确保TLS证书时间没有过期

### 异常处理

+ 可采用检查返回值的方法处理异常利用函数的返回值表示函数运行成功或失败，并在后续的代码中根据返回值作出相应的处理，如果应用程序发生错误，请不要留下可访问的敏感数据。将友好的错误信息返回给终端用户，不要包括细节信息，细节信息使攻击者有机会利用应用程序中的漏洞。
+ 抛出捕获异常只需要捕获需要处理的异常，过度捕获异常并不是一个好的习惯。这可能导致某些安全问题。捕获异常后如果需要向页面友好的提示，请自定义一段异常信息。
+ 创建全局错误处理程序。
+ 在设计异常处理功能时，还应该注意以下要素：
    1. 在应用程序遇到异常情况（如被零除情况或内存不足警告）时，就会产生异常。
    2. 发生异常时，控制流立即跳转到关联的异常处理程序（如果存在）。
    3. 如果给定异常没有异常处理程序，则程序将停止执行，并显示一条错误信息。
    4. 可能导致异常的操作通过try关键字来执行。
    5. 异常处理程序是在异常发生时执行的代码块。在C#中，catch关键字用于定义异常处理程序。
    6. 程序可以使用throw关键字显式地引发异常
    7. 异常对象包含有关错误的详细信息，其中包括调用堆栈的状态以及有关错误的文本说明
    8. 即使引发了异常，finally块中的代码也会执行，从而使程序可以释放资源

### 日志审计

日志审计功能应该面向两部分，针对应用系统关键业务操作进行日志审计，针对应用软件自身的异常信息进行记录，前者是为了提高业务操作上的可追溯性和抗抵赖功能，后者为了应用软件自身的健壮性，也便于日常运维。

#### 日志审计功能应该记录哪些事件


+ 对外部功能的调用和封装：应用中应该对外部系统和模块的调用前后都记下日志，以方便接口调试，出问题了也能快速定位和排除。
+ 应用程序状态变化：应用中重要的状态变化应该记录下来，方便排查问题的时候还原故障，推断程序运行过程，如系统功能和组件的启动和停止。
+ 业务异常：记录业务操作的异常行为(身份认证尝试、管理指令、更改对象所有权)，记录正常业务操作的关键字段。
+ 非预期执行：为应用程序在可能执行到的地方记录日志(“可能”是指通常情况下程序不会执行到这里，但某些情况下还是会执行这些代码)。
+ 完成一个关键请求所需要的时间，精确到毫秒。
+ 执行数据库查询的时间。
+ 从磁盘或者存储系统获取数据的时间等其他的I/O操作。
+ 程序运行时间：日志发生的日期和时间，包含时区信息和毫秒。
+ 大批量的数据执行进度(为了在关键时候定位响应缓慢或完全停止响应的情况发生)。
+ 日志级别：例如DEBUG、INFO和ERROR。
+ 业务的会话标识：能知道是哪个客户端或者是其他请求所产生的日志，简单的如IP地址、复杂一点的又如业务操作ID等，只要能区分不同的用户就足够。
+ 软件版本号。


#### 定义消息级别

应用程序在日志事件中以消息级别来定义异常的严重性，消息级别一共有7种，一般情况下5种就足够用了。

+ EMERG：灾难(Emergency)，应用系统发生极其严重的故障，导致系统完全不可访问，如后端服务不可用，数据库不可访问。
+ ERR：错误(error)，当遇到一些数据丢失，请求未处理完成等相关严重的错误是，使用此消息级别如：
    1. 请求未完成，而且没法恢复
    + 请求完成，数据丢失
    + 某些情况下保存数据失败
    + 接收到无效的数据
    + 超时或者响应时间太长
    + 处理异常
    + 安全相关问题

+ WARN：警告(Warnings)，表示某些奇怪的问题，这些问题应该在下一个版本中解决，系统运行是正常的，不用采取行动:

    1. 接收不到数据，或者计划外的数据
    2. 处理过程返回的状态未定义，但无误
    3. E-mails延迟，但仍可送达
    4. 响应时间比较长，但不会太严重
    5. 其他非错误问题

+ INFO：基本信息(Informactional)，应用程序中一些和错误、警告无关的信息记录，登录INFO:

    1. 事务启动，事务结束
    2. 发送某个email到某个地址
    3. 接收到来自某个IP的正常请求
    4. 获取某些用户详细资料

+ DEBUG：调试信息(Debug)，仅用于跟踪应用程序的运行状态，在release产品中应该停用此功能以节省系统资源。

    1. 使用Mailer适配器的参数值
    2. 请求参数名和值
    3. 数据库查询执行了多长时间以及返回多少条记录
    4. 堆栈跟踪

#### 日志记录功能避免犯以下错误

+ 混淆信息的LOG：日志记录应该是准确的，不要使用一些容易混淆的信息来记录一些操作行为。
+ 记错位置：例如使用console输出日志而在后期的排查中找不到相应的日志。
+ 记错级别：记错级别经常发生，例如混淆代码错误和用户错误，在登录功能中，例如存在恶意登录，系统内部可能会有大量的WARN信息，可能会让管理认为是代码错误。
+ 遗漏日志信息：用户少写了信息异常毫无参考价值；调用LOG的方式不正确导致异常丢失信息丢失。
+ 记录了多余的信息：应用程序的环境变量、dump、业务操作的关键信息(用户名、一些证件号码)。
+ 异常处理功能不应该改变应用程序的处理流程。


#### 处理已产生的日志文件

+ 集中日志记录集中式的日志记录有助于通过日志记录反映出一个统一的系统视角，并且方便查阅，例如使用外部的SYSLOG系统。
+ 保护日志文件日志文件应该存储在一个可靠的位置，避免被恶意修改。

### 数据保护

#### 基本原则

+ 实现严格的访问控制，限制用户只能访问按照完成任务要求的功能、数据和系统信息
+ 客户端上不以明文形式或其他非加密安全模式保存密码、连接字符串或其他秘密信息。
+ 删除不必要的注释，防止敏感信息泄露
+ 删除不需要的应用程序和系统文档
+ 敏感和隐私数据不能用通过HTTP GET方式传输
+ 禁止对敏感信息的自动填充功能
+ 禁止客户端缓存包含敏感信息的页面


#### 不正确的存储加密设计

任何加密方法都不是绝对可靠的，关键是使用破解成本远高于破解后的收益的加密功能，以下脆弱的加密设计方法经常出现：
+ 使用自己设计的加密算法
+ 强加密算法使用不当
+ 使用已知的弱加密算法(MD5、SHA-1、RC3、RC4等)
+ 采用非对称加密算法的同时，解密密钥保护不当，例如硬编码存储，并未对KEY进行加密保护

有的设计者会考虑使用加密算法+salt(或多次salt)的技术手段来确认生成的密文每次不固定，这样做可以大大增加破解难度，但这里会引入一个新的问题，如果salt值保护不当，也会较容易破解。

#### 设计存储加密功能

除了上面部分提到了注意的事项外，一个好的存储加密功能还应该考虑以下方法:

+ 使用不可逆、较强的加密算法。
+ 加密必须在可信的系统上完成。
+ 如果要使用salt，务必保护好salt值，硬编码写入代码中或者直接和被保护的数据一起存入数据库中都不可取的方法。
+ MD5加密算法虽然不可逆，但其在保证文件的一致性上已不可靠，在针对字符串的加密破解方式也多种多样，例如某些网站利用密文查询明文、使用庞大的彩虹表也能破解相当多的密码。

### 数据库安全

#### 基本原则

+ 为所有变量指定数据类型，确保变量是强类型的。
+ 应用程序访问数据库时，尽可能为最低权限。
+ 链接字符串在应用程序中应当不使用硬编码。连接字符串应当加密存储在一个可信任服务器的专用配置文件中。
+ 尽量使用存储过程和参数化查询以抽象访问数据。
+ 修改所有默认的数据库管理员密码。
+ 禁用或删除所有不需要的默认账户。
+ 关闭所有不需要的数据库功能（比如：不需要的存储过程或服务、应用包、仅最小化安装需要的特点和选项（表面范围缩减））。
+ 应用程序应当以不同的凭证为每个信任的角色（比如：用户、只读用户、访问用户、管理员）连接数据库。
+ 为数据库开启操作审计功能。


#### 使用参数化SQL语句

正确的使用参数化的SQL语句，就可以通过不允许数据指向改变的方法来防御几乎所有的SQL注入攻击。参数化的SQL语句通常是由SQL字符构造的，但是来自客户的数据是需要与一些绑定参数组合在一起的。
也就是说，开发者使用这些绑定参数来准确的向数据库指出哪些应该被当作数据那些应该被当作命令。当程序要执行该语句的时候，它就会告知数据库这些绑定参数的运行值，这样的操作避免了数据被认为是命令语句而被执行的错误。

#### 确保数据库资源能够被释放

由于资源泄露可能导致系统出现很难捕捉到的错误，所以应当建立一个资源管理模块并且完全按照规则进行操作。千万不要依赖Java和.NET的垃圾回收器来回收资源。垃圾回收器在进行回收之前还要检测对象是否适合进行垃圾回收。
除非虚拟机的内存已经很低，才会进行垃圾回收，这样无法保证即将被回收的对象是处于正常的状态。

### 文件安全

#### 严格控制文件上传

文件上传向来是应用系统最具威胁的安全风险点之一，因此应当严格控制。
+ 文件类型验证
    1. 检验上传文件的后缀名，限制只允许上传满足业务需求的文件类型。
    2. 不要把用户提供的数据直接传送给任意动态包含的功能。
    3. 验证文件头信息是否满足上传类型，一般文件内容的前10个字节能确定文件类型。
    4. 使用白名单记录允许的文件类型。
    5. 不要根据协议头内容来确认上传的文件类型。

+ 文件存储安全
    1. 不应该允许用户自行设定、选择存储路径和保存的文件名，严格检测提交数据中是否含有中断符。
    2. 上传文件最好保存在单独内容服务器或者数据库中，而不是服务器前端，例如被上传了crossdomain.xml，可能就会导致flash的跨域问题，这些都是实实在在的风险。
    3. 防止或限制上传的任意文件可能被服务器解析，在上传目录中关闭执行权限。
    4. 不要透露文件的目录或路径，文件上传成功后应该随时生成文件名，而不要从比如cookie之类的地方直接取一段hash出来。比较好的做法是在服务端上用类似random()一类的函数来生成，访问文件时采用索引的方式匹配文件。
    5. 确保应用程序文件和资源文件是只读的

+ 限制文件大小


#### 安全的临时文件

为了安全的使用临时文件，应该在程序初始化时创建一个只能被该程序读写的文件夹。不要将该文件夹放在用户可访问到的地方，并将所有的临时文件都放在其中。

#### 合规性安全功能

合规性安全功能是为了满足合规性安全需求，目前暂无。


***PS:附件可以参考master分支下的`安全设计参考规范附件.xlsx`表格***
