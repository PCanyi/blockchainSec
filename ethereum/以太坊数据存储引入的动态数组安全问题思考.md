# 以太坊数据存储引入的动态数组安全问题思考

## 前言

以太坊关于数据存储原理这里就不多讲，有需要的可以参考：

- [以太坊智能合约数据存储](./以太坊智能合约数据存储.md)

这里讨论的是由于数据存储引入的安全问题，请看下面。

## 示例代码

```
struct User{
    
    uint256 a;
    uint256 b;
}
User[] array;

    function t(uint256 _a,uint256 _b){
        User user;
        user.a=_a;
        user.b=_b;
        
        array.push(user);
        
    }
```

如上示例代码，定义了一个USer结构体和一个User类型的动态数组全局变量array，函数t的功能是实现初始化一个结构体对象user，并且对其赋值后存入到array数组。

在Remix上面我们部署好智能合约以后，我们调用一下函数t(2,2)，然后在Remix的Debugger上面调试，我们可以在Storage completed loaded看到数据的存储位置是：


```

    0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000000
        value: 0x0000000000000000000000000000000000000000000000000000000000000003
    0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000001
        value: 0x0000000000000000000000000000000000000000000000000000000000000002
    0x9c418048a637d1641c6d732dd38174732bbf7b47a1cf6d5f65895384518b07d9: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567
        value: 0x0000000000000000000000000000000000000000000000000000000000000003
    0x5306a7ea1091503364459f70885dc372117f70834621ea9300aa244571124d0a: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568
        value: 0x0000000000000000000000000000000000000000000000000000000000000002
        
```

先看t函数的执行流程：

step1：这里定义了一个局部结构体变量user，然后user.a=2,user.b=2。这里因为结构体复杂类型，所以虽然user是局部变量但是solidity还是按照storage来处理了。因此slot[0]=user.a=2,slot[1]=user.b=2。

step2：array是全局变量并且是第一个变量，因此array本来的location是0即占用slot[0]。按照动态数组的存储规则，array在进行push一个元素以后长度变为1，这个时候slot[0]存储的是array数组的长度1，但是这里slot[0]已经存储了user.a，因此这里slot[0]的值变为1+2=3。需要注意的是，按照[数据存储](./以太坊智能合约数据存储.md) 文章讲的是有冲突情况下直接覆盖，但是在动态数组中发现如果出现了数组长度的那个槽位出现了冲突，我们在push元素的时候，动态数组的长度是length+原始槽位的值。

step3：数据存储文章讲到冬天数组的第一个元素槽位是keccak256(location)，，第二个元素是keccak256(location)+1，以此类推。这里是0槽位，计算出来的是keccak256(0)=0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563，但是我们看到第一个元素位置是0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567，相当于0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563+4，其实我们根据这个可以猜猜到为啥。是因为本来如果array在push一个元素后，数组长度为1，那么第一个元素起始位置肯定是0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563。但是这里的数组长度已经变为3，那么肯定第一个元素长度是0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563+4（因为每一个元素是一个结构体，结构体里面又有两个元素，其实就是2*2）。

step4：最后肯定array数组push进来元素后，需要对0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567和0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568槽位进行塞进数据，这里塞进去的是user.a和user.b，其实也就是slot[0]和slot[1]。slot[0]和slot[1]已经根据前面分析的变为3和2，因此0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567和0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568槽位的数据分别是3和2。

**注意**

>从上面的第三步和第四步可以看到，这里经过部署代码发现，如果出现了动态数组存储数组长度的槽位比实际长度要长，那么数据占用的槽位就不会是keccak256(location)了，而是把数组存储在动态数组的最后一个存储位置上，即是array[存储动态数组长度槽位的值-1]。


如果多次这样，将会导致动态数组的长度和实际长度不符合，并且存储顺序也是乱序的。在经过多次调用t函数后，如果不花时间分析根本就不知道array的存储结构和值了。并且这里动态数组长度和每次push进去的结构体的元素的第一个元素a相关。那么就会出现两个问题：

- 动态数组的长度和实际长度不符合，并且存储顺序也是乱序。这样假如我们在取值的时候就取不到我们想要的值。
- 我们在进行动态数组循环遍历的时候例如：  
  
```

for(var i=0;i<array.length;i++){
          
		// do something ....
}

```
  在其他文章讲过，这里的i的定义其实是uint8，而length又和user.a的值相关，user.a类型为uint256，很有可能将会导致溢出，从而陷入死循环。
  
  
## 解决方案

复杂类型的局部变量添加关键字memory

```
struct User{
    
    uint256 a;
    uint256 b;
}
User[] array;

    function t(uint256 _a,uint256 _b){
        User memory user;
        user.a=_a;
        user.b=_b;
        
        array.push(user);
        
    }

```

有兴趣的可以去从新部署一下合约，多次调用t函数后，再去debugger里面查看会发现这个时候动态数组的存储结构和值都是正常的。
















































