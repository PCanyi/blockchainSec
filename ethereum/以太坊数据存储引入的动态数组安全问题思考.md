# 以太坊数据存储引入的动态数组安全问题思考

## 前言

以太坊关于数据存储原理这里就不多讲，有需要的可以参考：

- [以太坊智能合约数据存储](./以太坊智能合约数据存储.md)

这里讨论的是由于数据存储引入的安全问题，请看下面。

## 示例代码

```
struct User{
    
    uint256 a;
    uint256 b;
}
User[] array;

    function t(uint256 _a,uint256 _b){
        User user;
        user.a=_a;
        user.b=_b;
        
        array.push(user);
        
    }
```

如上示例代码，定义了一个USer结构体和一个User类型的动态数组全局变量array，函数t的功能是实现初始化一个结构体对象user，并且对其赋值后存入到array数组。

在Remix上面我们部署好智能合约以后，我们调用一下函数t(2,2)，然后在Remix的Debugger上面调试，我们可以在Storage completed loaded看到数据的存储位置是：


```

    0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000000
        value: 0x0000000000000000000000000000000000000000000000000000000000000003
    0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000001
        value: 0x0000000000000000000000000000000000000000000000000000000000000002
    0x9c418048a637d1641c6d732dd38174732bbf7b47a1cf6d5f65895384518b07d9: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567
        value: 0x0000000000000000000000000000000000000000000000000000000000000003
    0x5306a7ea1091503364459f70885dc372117f70834621ea9300aa244571124d0a: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568
        value: 0x0000000000000000000000000000000000000000000000000000000000000002
        
```

先看t函数的执行流程：

**分析：**

step1：这里定义了一个局部结构体变量user，然后user.a=2,user.b=2。这里因为结构体复杂类型，所以虽然user是局部变量但是solidity还是按照storage来处理了。因此slot[0]=user.a=2,slot[1]=user.b=2。

step2：array是全局变量并且是第一个变量，因此array本来的location是0即占用slot[0]。按照动态数组的存储规则，array在进行push一个元素以后长度变为1，这个时候slot[0]存储的是array数组的长度1，但是这里slot[0]已经存储了user.a，因此这里slot[0]的值变为1+2=3。需要注意的是，按照[数据存储](./以太坊智能合约数据存储.md) 文章讲的是有冲突情况下直接覆盖，但是在动态数组中发现如果出现了数组长度的那个槽位出现了冲突，我们在push元素的时候，动态数组的长度是length+原始槽位的值。

step3：数据存储文章讲到冬天数组的第一个元素槽位是keccak256(location)，，第二个元素是keccak256(location)+1，以此类推。这里是0槽位，计算出来的是keccak256(0)=0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563，但是我们看到第一个元素位置是0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567，相当于0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563+4，其实我们根据这个可以猜猜到为啥。是因为本来如果array在push一个元素后，数组长度为1，那么第一个元素起始位置肯定是0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563。但是这里的数组长度已经变为3，那么肯定第一个元素长度是0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563+4（因为每一个元素是一个结构体，结构体里面又有两个元素，其实就是2*2）。

step4：最后肯定array数组push进来元素后，需要对0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567和0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568槽位进行塞进数据，这里塞进去的是user.a和user.b，其实也就是slot[0]和slot[1]。slot[0]和slot[1]已经根据前面分析的变为3和2，因此0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567和0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568槽位的数据分别是3和2。

**注意**

>从上面的第三步和第四步可以看到，这里经过部署代码发现，如果出现了动态数组存储数组长度的槽位比实际长度要长，那么数据占用的槽位就不会是keccak256(location)了，而是把数组存储在动态数组的最后一个存储位置上，即是keccak256(location)+正常情况下的槽位和实际存储槽位直接的偏移。

我们再次调用一次t函数t(5,5)：

```
0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563: Object

    key: 0x0000000000000000000000000000000000000000000000000000000000000000
    value: 0x0000000000000000000000000000000000000000000000000000000000000006

0x5306a7ea1091503364459f70885dc372117f70834621ea9300aa244571124d0a: Object

    key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568
    value: 0x02

0x9c418048a637d1641c6d732dd38174732bbf7b47a1cf6d5f65895384518b07d9: Object

    key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567
    value: 0x03

0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6: Object

    key: 0x0000000000000000000000000000000000000000000000000000000000000001
    value: 0x0000000000000000000000000000000000000000000000000000000000000005

0x4a4dc7b36028fb3f9d05fc19190734f0a7ece2c30dc0173f06c4909365721185: Object

    key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56d
    value: 0x0000000000000000000000000000000000000000000000000000000000000006

0xd31af96c2e2fdbf596eef2a4a31d65a68b1fce22049159bf1b39bba52ee44476: Object

    key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56e
    value: 0x0000000000000000000000000000000000000000000000000000000000000005

```

**分析：**

step1：这里分析和第一次调用t函数分析步骤一致。这里slot[0]存储的是动态数组的长度，本来应该是为2，但是这里为6，那么明显的是5+1得来的。说明了动态数组每次在push一个元素以后，只是它只是在存储长度的槽位上面的值进行自增加1，即使length++。

step2：slot[1]的值如前面分析被填充为user.b即5。

step3：0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567和0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568槽位的值不会变。

step4：刚才如前面分析，这里数组长度的槽位变为了6，即是数组长度为6，这一次push进来的结构体的元素存储在0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56d和0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56e位置上。这里的存储位置末尾分别为d和e。d为13，e为14，本来应该存储在末尾为5和6，说明书偏移了4个存储位置。为啥，本来这个数组长度为2，那么第二个元素存储的位置末尾就是5和6，但是这里长度被覆盖为6，因此存储位置末尾就是d和e，即是相当于从2到6，偏移了4个存储位置。


再一次调用t函数t(1,1)，根据前面的分析这个时候数组长度本来为3，但是由于槽位被覆盖的问题，这个长度应该是1+1=2，此元素存储的位置末尾为5和6，这里并且slot[1]的值为user.b的值1。
让我们调用代码看看：

```
    0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000000
        value: 0x0000000000000000000000000000000000000000000000000000000000000002
    0x4a4dc7b36028fb3f9d05fc19190734f0a7ece2c30dc0173f06c4909365721185: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56d
        value: 0x06
    0x5306a7ea1091503364459f70885dc372117f70834621ea9300aa244571124d0a: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568
        value: 0x02
    0x9c418048a637d1641c6d732dd38174732bbf7b47a1cf6d5f65895384518b07d9: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567
        value: 0x03
    0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000001
        value: 0x0000000000000000000000000000000000000000000000000000000000000001
    0xd31af96c2e2fdbf596eef2a4a31d65a68b1fce22049159bf1b39bba52ee44476: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56e
        value: 0x05
    0x63d75db57ae45c3799740c3cd8dcee96a498324843d79ae390adc81d74b52f13: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565
        value: 0x0000000000000000000000000000000000000000000000000000000000000002
    0x68ebfc8da80bd809b12832608f406ef96007b3a567d97edcfc62f0f6f6a6d8fa: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e566
        value: 0x0000000000000000000000000000000000000000000000000000000000000001
```

从上可以看到，实际的存储位置和刚才分析的完全一致。

如果多次这样，将会导致动态数组的长度和实际长度不符合，并且存储顺序也是乱序的。在经过多次调用t函数后，如果不花时间分析根本就不知道array的存储结构和值了。并且这里动态数组长度和每次push进去的结构体的元素的第一个元素a相关。那么就会出现两个问题：

- 动态数组的长度和实际长度不符合，并且存储顺序也是乱序。这样假如我们在取值的时候就取不到我们想要的值。
- 我们在进行动态数组循环遍历的时候例如：  
  
```

for(var i=0;i<array.length;i++){
          
		// do something ....
}

```

在其他文章讲过，这里的i的定义其实是uint8，而length又和user.a的值相关，user.a类型为uint256，很有可能将会导致溢出，从而陷入死循环。

**在本次的讲解的例子中，总结一下有如下几点：**

- 数组的存储槽位的数值为被覆盖的值+1，这里既为user.a+1。
- 这里slot[1]的值存储的是user.b的值。
- 每调用一次函数，数据总是存储在array[length-1]即是数组最后一个元素的存储位置上。数据存储起始位置为keccak256(location)+实际存储位置和最后一个元素存储位置的偏移。
- 这里数组存储的元素值，实际取值是slot[0]和slot[1]。

  
  
## 解决方案

复杂类型的局部变量添加关键字memory

```
struct User{
    
    uint256 a;
    uint256 b;
}
User[] array;

    function t(uint256 _a,uint256 _b){
        User memory user;
        user.a=_a;
        user.b=_b;
        
        array.push(user);
        
    }

```

有兴趣的可以去从新部署一下合约，多次调用t函数后，再去debugger里面查看会发现这个时候动态数组的存储结构和值都是正常的。这里我们再次调用t(2,2)，t(5,5)，t(1,1)。调用后的存储位置如下：

```
    0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563: Object
        key: 0x0000000000000000000000000000000000000000000000000000000000000000
        value: 0x0000000000000000000000000000000000000000000000000000000000000003
    0x510e4e770828ddbf7f7b00ab00a9f6adaf81c0dc9cc85f1f8249c256942d61d9: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563
        value: 0x02
    0x63d75db57ae45c3799740c3cd8dcee96a498324843d79ae390adc81d74b52f13: Object
    0x68ebfc8da80bd809b12832608f406ef96007b3a567d97edcfc62f0f6f6a6d8fa: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e566
        value: 0x05
    0x6c13d8c1c5df666ea9ca2a428504a3776c8ca01021c3a1524ca7d765f600979a: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564
        value: 0x02
    0x9c418048a637d1641c6d732dd38174732bbf7b47a1cf6d5f65895384518b07d9: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e567
        value: 0x0000000000000000000000000000000000000000000000000000000000000001
    0x5306a7ea1091503364459f70885dc372117f70834621ea9300aa244571124d0a: Object
        key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e568
        value: 0x0000000000000000000000000000000000000000000000000000000000000001

```

从上面可以看到这个时候数组长度在slot[0]，长度为3。数据存储是从0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563开始偏移了3个存储位置，数组长度和数据存储位置以及数据存储值都是正常的。并且也不会出现slot[1]槽位被占用的情况。
















































