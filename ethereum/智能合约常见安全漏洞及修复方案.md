---

title: 智能合约常见安全漏洞及修复方案

author: bobby

---

# 智能合约常见安全漏洞及修复方案

# 前言介绍

最近区块链漏洞不要太火，什么交易所用户被钓鱼导致 APIKEY 泄漏，代币合约出现整数溢出漏洞致使代币归零， MyEtherWallet 遭 DNS 劫持致使用户 ETH 被盗等等。频频爆出的区块链安全事件，越来越多的安全从业者将目标转到了 Blockchain 上。本文将从以太坊智能合约的一些特殊机制说起，详细地剖析已发现各种漏洞类型，对每一种漏洞类型都会提供一段简单的合约代码来对漏洞成因和攻击方法进行说明。

## 使用对象

本规范的读者及使用对象主要为智能合约开发者、测试、安全相关人员。

## 使用目标

1、智能合约开发者能够了解智能合约常见的安全漏洞和修复方案。

2、测试和安全相关人员能够对智能合约进行安全测试，包括源码审计方法和渗透测试方法。

3、团队管理者等其他管理人员对目前主要的智能安全漏洞有一定的认识。

# 目录

## 溢出漏洞

* [整数溢出](#整数溢出)

## 越权访问

* [delegatecall](#delegatecall)
* [默认可见性](#默认可见性)
* [谨慎构造函数](#谨慎构造函数)

## 信息泄漏

暂未找到相关材料分析

## 逻辑错误

* [Reentrancy攻击](#Reentrancy攻击)
* [Unchecked-Send漏洞](#Unchecked-Send漏洞)
* [An Attack Vector on Approve/TransferFrom Methods](# 'An Attack Vector on Approve/TransferFrom Methods')

## 拒绝服务

* [通过(Unexpected) Revert发动DoS](# '通过(Unexpected) Revert发动DoS')
* [通过区块Gas Limit发动DoS](# '通过区块Gas Limit发动DoS')
* [所有者操作发动DoS](# '所有者操作发动DoS')
* [死循环类型拒绝服务](#死循环类型拒绝服务)

## 函数误用
* [Bad Randomness - 可预测的随机处理](# 'Bad Randomness - 可预测的随机处理')
* [不期而至的Ether](#'不期而至的Ether')
* [Tx.Origin身份验证](#Tx.Origin身份验证)

# 漏洞列表

## 溢出漏洞

### 整数溢出

#### 漏洞描述

以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整型变量只能有一定范围的数字表示。A uint8例如，只能存储在范围[0,255]的数字。试图存储256到一个uint8将导致0。如果不注意，如果不选中用户输入并执行计算，导致数字超出存储它们的数据类型的范围，则可以利用Solidity中的变量。

当执行操作需要固定大小的变量来存储超出变量数据类型范围的数字（或数据）时，会发生溢出。

#### 漏洞危害

可能导致合约失效、无限发币等风险。例如攻击者就可以利用这个漏洞，可无限制的将任意账户的代币token转到指定的账户(_to)，从而导致所有持有次代币的账户都有可能被盗取，严重危害了用户的财产安全。

#### 产生原理

  * 上溢错误
  
 数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
	+0x000000000000000000000000000000000001  
	=0x000000000000000000000000000000000000
数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0	  到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
	+0x000000000000000000000000000000000001  
    =0x000000000000000000000000000000000000
    
  * 下溢错误
  	
好了，看看另个极端，也就是下溢错误。Over跟under是反义词。这俩错误也是反着来的。
	uint8只能取0到255之间的值，还记得吧？ 那么，考虑以下代码。
	unint8 a = 0;
	a–;
	这就是下溢，后果是a的最大可能值是255。
	出现在Solidity智能合约中，就是这：  
    
	0x000000000000000000000000000000000000  
	–0x000000000000000000000000000000000001  
	=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

#### 案例分析 BEC智能合约致命漏洞

  * 安全事件
  
	最近，智能合约漏洞很火。让我们再来看一下4月22日BeautyChain（BEC）的智能合约中一个毁灭性的漏洞。BeautyChain团队宣布，BEC代币在4月22日出现异常。攻击者通过智能合约漏洞成功转账了10^58 BEC到两个指定的地址。
    
	具体交易详情[https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f](https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f)
	攻击者到底是怎么攻击的？为什么能转账这么大的BEC？
    
  * 智能合约代码
  
首先我们来看BEC转账的智能合约代码
 
    
    ```
    
    function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
        uint cnt = _receivers.length;
        uint256 amount = uint256(cnt) * _value;
        require(cnt > 0 && cnt <= 20);
        require(_value > 0 && balances[msg.sender] >= amount);
     
        balances[msg.sender] = balances[msg.sender].sub(amount);
        for (uint i = 0; i < cnt; i++) {
            balances[_receivers[i]] = balances[_receivers[i]].add(_value);
            Transfer(msg.sender, _receivers[i], _value);
        }
        return true;
     }
    
    ```
    
 以上的代码是Solidity语言，是一门面向合约的，为实现智能合约而创建的高级编程语言。
    
  * 代码解读
  
知道了这几个变量类型，下面我们一行一行的来读这段代码。
    
第一行
    
	function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused 		returns (bool);
    
函数有两个参数:
    _receivers —————转账接收人，address类型的变量数组，是一个160位的值。
    _value ———————-转账数量，uint256的状态变量，256位的无符号整数。
    定义函数batchTransfer，功能主要是实现转账，接收两个参数，定义了参数的取值范围。
    
第二行
    
	uint cnt = _receivers.length;

计算接收人地址对应地址数组的长度，即转账给多少人。
    
第三行
    
    uint256 amount = uint256(cnt) * _value;
    
把unit类型的cnt参数值强制转换为uint256然后乘以转账数量_value 并赋值给uint256类型的amount变量。
    
第四行
    
    require(cnt > 0 && cnt <= 20);
    
require函数
require的入参判定为 false，则终止函数，恢复所有对状态和以太币账户的变动，并且也不会消耗 gas 。判断cnt是否大于0且cnt是否小于等于20
    
第五行
    
    require(_value > 0 && balances[msg.sender] >= amount);
    
参数解读:
_value—————————————转账数量

balances[msg.sender]————-转账人余额

amount————————————转账总数量

判断_value是否大于0且转账人的余额balances[msg.sender]大于等于转账总金额amount

第六行

    balances[msg.sender] = balances[msg.sender].sub(amount);
    
计算转账人的余额，使用当前余额balances[msg.sender]减去转账总数量

第七行

    for (uint i = 0; i < cnt; i++) {
    
这里是一个循环，循环次数为cnt（遍历转账地址）

第八行

    balances[_receivers[i]] = balances[_receivers[i]].add(_value);
    
当i有具体的值时，balances[_receivers[i]]表示转账接收人，这里是表示转账人给转账接收人_value数量的币。

第九行

    Transfer(msg.sender, _receivers[i], _value);

保存转账记录

第十行

    return true;
    
函数返回为True
    
  * 代码流程
    
OK，我们读了完整的代码，接下来请看一个流程图

  * 攻击过程

其实，他只是细心了一点，所使用的攻击方法并不高明啊，你且听我慢慢道来，注意看，别走神啊。
    
  * 交易详情
  
我们首先看这笔详细的交易：
    
我们从图可以看到转账接收人有两个地址，即balances[_receivers]:
    000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033
    0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7
    转账数量为_value:
    8000000000000000000000000000000000000000000000000000000000000000（十六进制）
    转10进制为
    57896044618658097711785492504343953926634992332820282019728792003956564819968
    OK，接下来我们来走函数流程

第一行

    function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool)

正常执行

第二行

    uint cnt = _receivers.length

由于这里有两个转账接收人地址，address数组长度为2，所以cnt为2，类型为uint

第三行

    uint256 amount = uint256(cnt) * _value;   
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968
    cnt=2
    
两者相乘得到amount，类型为uint256
即amount=115792089237316195423570985008687907853269984665640564039457584007913129639936
考试重点用上了，记不住的同学去前面看看。
amount的类型为uint256，那么按照理论，它的最大取值是0到2^256减1，即
115792089237316195423570985008687907853269984665640564039457584007913129639935
所以amount瞬间从115792089237316195423570985008687907853269984665640564039457584007913129639936变成了0
第三行得到的结果：amount=0

第四行

    require(cnt > 0 && cnt <= 20);
    cnt=2，2肯定大于0，2当然也小于等于20

所以这个条件成立，require函数返回值为True。

第五行

    require(_value > 0 && balances[msg.sender] >= amount);
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968

_value肯定是大于0，转账人的余额balances[msg.sender]肯定是大于等于0的。所以这个条件同样成立，require函数返回值为True。

第六行

    balances[msg.sender] = balances[msg.sender].sub(amount); 前面的条件都成立，那么代码会执行到这。

这行代码是求转账人转完账以后剩下的余额，amount为0 ，那么转账人的余额其实没变！！！
    
第七行

    for (uint i = 0; i < cnt; i++)

cnt=2，该行代码表示执行两次后面的操作

第八行
    
    balances[_receivers[i]] = balances[_receivers[i]].add(_value);  
    
i=0时，转账接收人balances[_receivers[0]]的余额加_value
i=1时，转账接收人balances[_receivers[1]]的余额加_value
看到这里其实我们就很明白了吧。

攻击者给以下两个转账接收人
        000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033
        0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7
转了
_value=57896044618658097711785492504343953926634992332820282019728792003956564819968个币

更可恶的是，攻击者执行完这个操作，转账人的余额根本没变，看代码第六行的执行结果。

第九行

    Transfer(msg.sender, _receivers[i], _value);

这里只是把上面两个转账记录保存。

第十行

    return true;
    
函数返回为True
    
参考链接：[https://blog.csdn.net/Fly_hps/article/details/80732159](https://blog.csdn.net/Fly_hps/article/details/80732159)

#### 修复方案
  
为了避免整数溢出，可以将条件判断改为比较操作，例如：require(balances[msg.sender] > _amount)，这样就不会执行算术操作进行进行逻辑判断，一定程度上避免了整数溢出的发生。

为了防止整数溢出的发生，一方面可以在算术逻辑前后进行验证，另一方面可以直接使用 OpenZeppelin 维护的一套智能合约函数库中的 SafeMath 来处理算术逻辑。[OppenZepplin](https://github.com/OpenZeppelin/zeppelin-solidity) 在构建和审计 Ethereum 社区可以利用的安全库方面做得非常出色。特别是，他们的 [SafeMath](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol) 是一个用来避免上溢/下溢漏洞的参考或库。

```

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b); 
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b; 
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```

## 越权访问

### delegatecall

#### 漏洞描述

 ` CALL ` 与 ` DELEGATECALL ` 操作码是非常有用的，它们让 Ethereum 开发者将他们的代码模块化（Modularise）。用 ` CALL ` 操作码来处理对合约的外部标准信息调用（Standard Message Call）时，代码在外部合约/功能的环境中运行。 ` DELEGATECALL ` 操作码也是标准消息调用，但在目标地址中的代码会在调用合约的环境下运行，也就是说，保持 ` msg.sender ` 和 ` msg.value ` 不变。该功能支持实现库，开发人员可以为未来的合约创建可重用的代码。 

delegatecall() 与call()的不同是 delegatecall()仅仅是调用代码，但是处理的还是调用者合约的数据，所以要保证两个合约的存储变量能兼容，相当于把外部合约的代码粘贴复制过来处理本合约的数据，就是插入一段代码。

这些call调用都是很低层的调用，当调用一个恶意的合约时，他可能会回调你的合约，所以要准备在调用返回时应对状态变量被篡改的情况。

虽然这两个操作码之间的区别很简单直观，但是使用 ` DELEGATECALL ` 可能会导致意外的代码执行。

有关进一步阅读，请参阅 [Stake Exchange上关于以太坊的这篇提问](https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall)，[Solidity 官方文档](http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)以及[如何保护您的智能合约：6](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)。

 ` DELEGATECALL ` 会保持调用环境不变的属性表明，构建无漏洞的定制库并不像人们想象的那么容易。库中的代码本身可以是安全的，无漏洞的，但是当在另一个应用的环境中运行时，可能会出现新的漏洞。


#### 漏洞危害

引入恶意合约代码到本合约执行，进行提升权限为合约owner，或者进行恶意转账等恶意操作。

#### 产生原理

下面代码是 OpenZeppelin CTF 中的题目：

```
    pragma solidity ^0.4.10;
     
    contract Delegate {
        address public owner;
     
        function Delegate(address _owner) {
            owner = _owner;
        }
        function pwn() {
            owner = msg.sender;
        }
    }
     
    contract Delegation {
        address public owner;
        Delegate delegate;
     
        function Delegation(address _delegateAddress) {
            delegate = Delegate(_delegateAddress);
            owner = msg.sender;
        }
        function () {
            if (delegate.delegatecall(msg.data)) {
                this;
            }
        }
    }
    
```

仔细分析代码，合约 Delegation 在 fallback 函数中使用 msg.data 对 Delegate 实例进行了 delegatecall() 调用。msg.data 可控，这里攻击者直接用 bytes4(keccak256("pwn()")) 即可通过 delegatecall() 将已部署的 Delegation owner 修改为攻击者自己（msg.sender）。

注意：我理解的这个delegatecall的危害在于可以插入一部分代码到原合约的逻辑中，相当于插入一段代码，如果delegatecall的调用地址可以通过某种手段控制，那么可以插入任何代码(个人见解)。

#### 案例分析 Parity Multisig Wallet（Second Hack）

Parity 多签名钱包第二次被黑事件是一个例子，说明了如果在非预期的环境中运行，良好的库代码也可以被利用。关于这次被黑事件，有很多很好的解释，比如这个概述：Anthony Akentiev 写的 [再一次解释 Parity 多签名钱包被黑事件](https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838)，这个[stack exchange 上的问答](https://ethereum.stackexchange.com/questions/30128/explanation-of-parity-library-suicide/30130)和[深入了解Parity Multisig Bug](http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/)。

要深入理解这些参考资料，我们要探究一下被攻击的合约。受攻击的库合约和钱包合约可以在 [Parity 的 github](https://github.com/paritytech/parity/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol) 上找到。

我们来看看这个合约的相关方面。这里有两个包含利益的合约，库合约和钱包合约。

先看 library 合约， 

```solidity
contract WalletLibrary is WalletEvents {
  
  ...
  
  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // kills the contract sending everything to  ` _to ` .
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }
  
  ...
  
}
```

再看钱包合约，

```solidity
contract Wallet is WalletEvents {

  ...

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
      _walletLibrary.delegatecall(msg.data);
  }
  
  ...  

  // FIELDS
  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;
}
```

请注意，Wallet 合约基本上会通过 delegate call 将所有调用传递给 WalletLibrary。此代码段中的常量地址 ` _walletLibrary `，即是实际部署的 WalletLibrary 合约的占位符（位于 ` 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4 ` ）。

这些合约的预期运作是生成一个简单的可低成本部署的 Wallet 合约，合约的代码基础和主要功能都在 WalletLibrary 合约中。不幸的是，WalletLibrary 合约本身就是一个合约，并保持它自己的状态。你能能不能看出为什么这会是一个问题？

因为有可能向 WalletLibrary 合约本身发送调用请求。具体来说，WalletLibrary 合约可以初始化，并被用户拥有。一个用户通过调用 WalletLibrary 中的 ` initWallet() ` 函数，成为了 Library 合约的所有者。同一个用户，随后调用 ` kill() ` 功能。因为用户是 Library 合约的所有者，所以修改传入、Library 合约自毁。因为所有现存的 Wallet 合约都引用该 Library 合约，并且不包含更改引用的方法，因此其所有功能（包括取回 Ether 的功能）都会随 WalletLibrary 合约一起丢失。更直接地说，这种类型的 Parity 多签名钱包中的所有以太都会立即丢失或者说永久不可恢复。


#### 修复方案

Solidity 为实现库合约提供了关键字 ` library ` （参见 [Solidity Docs](http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#libraries) 了解更多详情)。这确保了库合约是无状态（Stateless）且不可自毁的。强制让 library 成为无状态的，可以缓解本节所述的存储环境的复杂性。无状态库也可以防止攻击者直接修改库状态的攻击，以实现依赖库代码的合约。作为一般的经验法则，在使用时 ` DELEGATECALL ` 时要特别注意库合约和调用合约的可能调用上下文，并且尽可能构建无状态库。

### 默认可见性

#### 漏洞描述

 Solidity 中的函数具有可见性说明符，它们会指定我们可以如何调用函数。可见性决定一个函数是否可以由用户或其他派生契约在外部调用、只允许内部调用或只允许外部调用。有四个可见性说明符，详情请参阅 [Solidity 文档](http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters)。为允许用户从外部调用函数，函数的可见性默认为 ` public `。

#### 漏洞危害

正如本节将要讨论的，可见性说明符的不正确使用可能会导致智能合约中的一些资金流失。

#### 产生原理

函数的可见性默认是 ` public `。因此，不指定任何可见性的函数就可以由用户在外部调用。当开发人员错误地忽略应该是私有的功能（或只能在合约本身内调用）的可见性说明符时，问题就出现了。
让我们快速浏览一个简单的例子。

```solidity
contract HashForEther {
    
    function withdrawWinnings() {
        // Winner if the last 8 hex characters of the address are 0. 
        require(uint32(msg.sender) == 0);
        _sendWinnings();
     }
     
     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}
```

这个简单的合约被设计为充当赏金猜测游戏的地址。要赢得该合约的余额，用户必须生成一个以太坊地址，其最后 8 个十六进制字符为0。一旦获得，他们可以调用 ` WithdrawWinnings() ` 函数来获得赏金。
不幸的是，这些功能的可见性没有得到指定。特别是，因为 ` _sendWinnings() ` 函数的可见性是 ` public `，任何地址都可以调用该函数来窃取赏金。

#### 案例分析 Parity MultiSig Wallet（First Hack）

在 Parity 多签名钱包遭受的第一次黑客攻击中，约值 3100 万美元的 Ether 被盗，主要是三个钱包。Haseeb Qureshi 在[这篇文章](https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce)中给出了一个很好的回顾。

实质上，这些多签名钱包（可以在[这里](https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol)找到）是从一个基础的 ` Wallet ` 合约构建出来的，该基础合约调用包含核心功能的库合约（如[真实世界中的例子：Parity Multisig（Second Hack）](#真实世界示例parity-multisig-walletsecond-hack)中所述)。库合约包含初始化钱包的代码，如以下代码片段所示

```solidity
contract WalletLibrary is WalletEvents {
  
  ... 
  
  // METHODS

  ...
  
  // constructor is given number of sigs required to do protected "onlymanyowners" transactions
  // as well as the selection of addresses capable of confirming them.
  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  ...

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}
```

请注意，这两个函数都没有明确指定可见性。两个函数的可见性都默认为 ` public ` 。钱包构造函数会调用 ` initWallet() ` 函数，并设置多签名钱包的所有者，如 ` initMultiowned() ` 函数中所示。由于这些函数意外地设置为 ` public `，攻击者可以在部署的合约上调用这些功能，并将所有权重置为攻击者地址。作为拥有者，袭击者随后取走钱包中所有的 Ether，损失高达 3100 万美元。

#### 修复方案

总是指定合约中所有功能的可见性、即便这些函数的可见性本就有意设计成 ` public `，这是一种很好的做法。最近版本的 Solidity 将在编译过程中为没有明确设置可见性的函数显示警告，以鼓励这种做法。

### 谨慎构造函数

#### 漏洞描述

构造函数是特殊函数，在初始化合约时经常执行关键的特权任务。在solidity v0.4.22构造函数被定义为与包含它们的合约名称相同的函数之前。因此，如果合约名称在开发过程中发生变化，如果构造函数名称没有更改，它将变成正常的可调用函数。


#### 漏洞危害

如果合约名称被修改，或者在构造函数名称中存在拼写错误以致它不再与合约名称匹配，则构造函数的行为将与普通函数类似。这可能会导致可怕的后果，特别是如果构造函数正在执行特权操作。


#### 产生原理

考虑以下合约：

```solidity
contract OwnerWallet {
    address public owner;

    //constructor
    function ownerWallet(address _owner) public {
        owner = _owner;
    }
    
    // fallback. Collect ether.
    function () payable {} 
    
    function withdraw() public {
        require(msg.sender == owner); 
        msg.sender.transfer(this.balance);
    }
}
```

该合约收集以太，并只允许所有者通过调用该withdraw()函数来撤销所有以太。这个问题是由于构造函数没有完全以合约名称命名的。具体来说，ownerWallet是不一样的OwnerWallet。因此，任何用户都可以调用该ownerWallet()函数，将自己设置为所有者，然后通过调用将合约中的所有内容都取出来withdraw()。

#### 案例分析 MorphToken智能合约构造函数大小写编码错误漏洞

[链接一](http://www.freebuf.com/vuls/175904.html)  
[链接二](https://bcsec.org/index/detail?id=157&tag=1)
* 漏洞描述

以太坊智能合约的含义就是一组代码（函数）和数据（合约的状态），它们位于以太坊区块链的一个特定地址上。智能合约一般使用solidity语言编写。
  
Morpheus Network与世界上一些大型航运、海关和银行公司协商，通过利用区块链的智能合约技术建立一个全面服务的、全球性的、自动化的、开放的供应链平台和一个集成的加密货币支付系统 ，发布基于以太坊的 MorphToken。
    
2018年6月22日，Morpheus Network 发公告称将发布新的智能合约，以更新目前含有漏洞的合约代码。新的Token名称为MRPH，新旧Token以1:1兑换。
    
随后，知道创宇404区块链安全研究团队开始漏洞应急，通过分析MorphToken合约代码和交易历史，确定该漏洞是由于大小写编码问题，错误的将Owned合约的构造函数Owned的首字母小写，使之成为了一个普通函数owned，任何以太坊账户均可调用该函数夺取合约的所有权，进一步实现盗币等系列非法操作。随即我们发布了相关应急报告，同时我们也注意到BCSEC安全团队发布了相关的分析文档。
    
在后续的研究中，我们发现早在2017年8月29日，Github上就有人提到了这种因构造函数缺失导致的合约安全漏洞问题。该漏洞目前影响包括MorphToken、B2X、DoubleOrNothingImpl等多个智能合约。

* 漏洞原理

在MorphToken的合约代码里：[https://etherscan.io/address/0x2ef27bf41236bd859a95209e17a43fbd26851f92#code ](https://etherscan.io/address/0x2ef27bf41236bd859a95209e17a43fbd26851f92#code )可以明显的看到相关大小写编写错误：

```
    contract Owned {
        address public owner;

        function owned() public {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
        
        /* This function is used to transfer adminship to new owner
         * @param  _newOwner - address of new admin or owner        
         */

        function transferOwnership(address _newOwner) onlyOwner public {
            owner = _newOwner;
        }          
    }
```

以太坊智能合约中的构造函数主要用于初始化，如：确定合约的所有者，并且只会在合约部署时运行。在小于0.4.22版本的solidify编译器语法要求中，构造函数的名称应该和合约名称保持一致。如果程序员在编写合约时将构造函数名称写错，那么原本的构造函数将成为任何人都可以调用的普通函数。

#### 修复方案

这个问题已经在Solidity编译器的版本中得到了主要解决0.4.22。该版本引入了一个constructor指定构造函数的关键字，而不是要求函数的名称与契约名称匹配。建议使用此关键字来指定构造函数，以防止上面的命名问题。


## 信息泄漏


## 逻辑错误

### Reentrancy攻击

#### 漏洞描述

以太坊智能合约的特点之一是能够调用和利用其他外部合约的代码。合约通常也处理Ether，因此通常会将Ether发送给各种外部用户地址。调用外部合约或将以太网发送到地址的操作需要合约提交外部调用。这些外部调用可能被攻击者劫持，迫使合约执行进一步的代码（即通过回退函数），包括回调自身。因此代码执行“ 重新进入 ”合约。这种攻击被用于臭名昭着的DAO攻击。

有关重入攻击的进一步阅读，请参阅[对智能合约的重入式攻击](https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4)和 [Consensus - 以太坊智能合约最佳实践](https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert)。

#### 漏洞危害

当合约将 Ether 发送到未知地址时，可能会发生此攻击。攻击者可以在 [Fallback 函数](https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function)中的外部地址处构建一个包含恶意代码的合约。因此，当合约向此地址发送 Ether 时，它将调用恶意代码。通常，恶意代码会在易受攻击的合约上执行一个函数、该函数会运行一项开发人员不希望的操作。“重入”这个名称来源于外部恶意合约回复了易受攻击合约的功能，并在易受攻击的合约的任意位置“重新输入”了代码执行。

可能导致基于重入漏洞的恶意转账等风险。

#### 产生原理

智能合约转账以太币：  
address x = 0x123;  
address myAddress = this;  
if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);  
智能合约还可以通过x.call.value()()、x.send()方式转账。他们的区别在于：

	transfer() 
    
当发送失败时会 throw; 回滚状态  
只会传递 2300 Gas 供调用，防止重入（reentrancy）

	send() 
    
当发送失败时会返回 false 布尔值  
只会传递 2300 Gas 供调用，防止重入（reentrancy）

	gas().call.value()() 
    
当发送失败时会返回 false 布尔值  
传递所有可用 Gas 进行调用（可通过 gas(gas_value) 进行限制），不能有效防止重入（reentrancy）
如果如果x是合约地址，x合约的回退函数（fallback 函数）会随transfer、send、call调用一起执行（这个是EVM特性）。x合约必须必须显示的实现回退函数，例如function () payable{}。  
下面用具体代码例子分析：
该合约充当以太坊保险库，允许存款人每周只提取1个Ether：

```
contract EtherStore {
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    
    }

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
    // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
    // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    
    }

}

```

该合约有两个公共职能。depositFunds()和withdrawFunds()。该depositFunds()功能只是增加发件人余额。该withdrawFunds()功能允许发件人指定要撤回的wei的数量。如果所要求的退出金额小于1Ether并且在上周没有发生撤回，它才会成功。还是呢？...	
该漏洞出现在[17]行，我们向用户发送他们所要求的以太数量。考虑一个恶意攻击者创建下列合约：

```

contract Attack {
    EtherStore public etherStore;
        // intialise the etherStore variable with the contract address
        constructor(address _etherStoreAddress) {
        etherStore = EtherStore(_etherStoreAddress);
    }
    
    function pwnEtherStore() public payable {
        // attack to the nearest ether
        require(msg.value >= 1 ether);
        // send eth to the depositFunds() function
        etherStore.depositFunds.value(1 ether)();
        // start the magic
        etherStore.withdrawFunds(1 ether);
    }
    
    function collectEther() public {
    msg.sender.transfer(this.balance);
    }
    // fallback function - where the magic happens
    
    function () payable {
        if (etherStore.balance > 1 ether) {
        etherStore.withdrawFunds(1 ether);
        }
    }
}

```

让我们看看这个恶意合约是如何利用我们的EtherStore合约的。攻击者可以0x0...123使用EtherStore合约地址作为构造函数参数来创建上述合约（假设在地址中）。这将初始化并将公共变量etherStore指向我们想要攻击的合约。
然后攻击者会调用这个pwnEtherStore()函数，并且有一些以太（大于或等于1），1 ether这个例子可以说。在这个例子中，我们假设一些其他用户已经将以太币存入这份合约中，这样它的当前余额就是10 ether。然后会发生以下情况：	
1. Attack.sol -Line[15] -的depositFunds()所述EtherStore合约的功能将与被叫msg.value的1 ether（和大量gas）。sender（msg.sender）将是我们的恶意合约（0x0...123）。因此，balances[0x0..123] = 1 ether。
2. Attack.sol - Line [17] - 恶意合约将使用一个参数来调用合约的withdrawFunds()功能。这将通过所有要求（合约的行[12] - [16] ），因为我们以前没有提款。
3. EtherStore.sol - 行[17] - 合约将发送1 ether回恶意合约。
4. Attack.sol - Line [25] - 发送给恶意合约的以太网将执行后备功能。
5. Attack.sol - Line [26] - EtherStore合约的总余额是10 ether，现在9 ether是这样，如果声明通过。
6. Attack.sol - Line [27] - 回退函数然后EtherStore withdrawFunds()再次调用该函数并“ 重新输入 ” EtherStore合约。
7. EtherStore.sol - 行[11] - 在第二次调用时withdrawFunds()，我们的余额仍然1 ether是行[18]尚未执行。因此，我们仍然有balances[0x0..123] = 1 ether。lastWithdrawTime变量也是这种情况。我们再次通过所有要求。
8. EtherStore.sol - 行[17] - 我们撤回另一个1 ether。
9. 步骤4-8将重复 - 直到EtherStore.balance >= 1[26]行所指定的Attack.sol。
10. Attack.sol - Line [26] - 一旦在EtherStore合约中留下少于1（或更少）的ether，此if语句将失败。这样就EtherStore可以执行合约的[18]和[19]行（每次调用withdrawFunds()函数）。
11. EtherStore.sol - 行[18]和[19] - balances和lastWithdrawTime映射将被设置并且执行将结束。
最终的结果是，攻击者已经从EtherStore合约中立即撤销了所有（第1条）金额，只需一笔交易即可。


#### 案例分析 Dao安全事件

在DAO源码中，有withdrawRewardFor函数：

```
    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {
      if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])
        throw;
      uint reward =
        (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
      if (!rewardAccount.payOut(_account, reward)) //vulnerable
        throw;
      paidOut[_account] += reward;
      return true;
    }
    
```
这里调用了payOut函数进行付款。

```
    
    function payOut(address _recipient, uint _amount) returns (bool) {
      if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
          throw;
      if (_recipient.call.value(_amount)()) { //vulnerable
          PayOut(_recipient, _amount);
          return true;
      } else {
          return false;
    }
```

而payOut中直接使用的是message call的方式发送以太币，从而导致了重入漏洞。

#### 修复方案

有许多常用技术可以帮助避免智能合约中潜在的重入漏洞。  

首先是（在可能的情况下）在将 Ether 发送给外部合约时使用内置的 [transfer() 函数](http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related)。转账功能只发送 ` 2300 gas ` 不足以使目的地址/合约调用另一份合约（即重入发送合约）。

第二种技术是确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol - 行[18]和行[19] 应放在 行[17] 之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为[检查效果交互（checks-effects-interactions）](http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern)模式。

第三种技术是引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用。

给 EtherStore.sol 应用所有这些技术（同时使用全部三种技术是没必要的，只是为了演示目的而已）会出现如下的防重入合约：

```solidity
contract EtherStore {

    // initialise the mutex
    bool reEntrancyMutex = false;
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(!reEntrancyMutex);
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
        // set the reEntrancy mutex before the external call
        reEntrancyMutex = true;
        msg.sender.transfer(_weiToWithdraw);
        // release the mutex after the external call
        reEntrancyMutex = false; 
    }
 }
```
### Unchecked-Send漏洞

参考文档：[http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/](http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/)

#### 漏洞描述

Solidity 中有很多方法可以执行外部调用。向外部账户发送 Ether 通常通过 transfer() 方法完成。不过，也可以使用 send() 功能，而且，对于更多功能的外部调用，在 Solidity 中可以直接使用 CALL 操作码。 call() 和 send() 函数会返回一个布尔值，显示调用是成功还是失败。因此，这些功能有一个简单的警告作用，如果（由 call() 或 send() 初始化的）外部调用失败，执行这些函数的交易将不会回滚，反而 call() 或 send() 将简单地返回 false 。


#### 漏洞危害

当没有检查返回值时，会出现一个常见的错误，并不是开发人员希望的那样发生回滚。


#### 产生原理


考虑下面的例子：

```solidity
contract Lotto {

    bool public payedOut = false;
    address public winner;
    uint public winAmount;
    
    // ... extra functionality here 

    function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
    
    function withdrawLeftOver() public {
        require(payedOut);
        msg.sender.send(this.balance);
    }
}
```

这份合约代表了一个类似于大乐透的合约，在这种合约中，winner收到winAmount了ether，通常只剩下一点让任何人退出。

该错误存在于第[11]行，其中使用send()而不检查响应。在这个微不足道的例子中，可以将winner其事务失败（无论是通过耗尽gas、故意抛出回退函数还是通过调用堆栈深度攻击的合约）payedOut设置为true（无论是否发送了以太币） 。在这种情况下，公众可以winner通过该withdrawLeftOver()功能撤回奖金。

#### 案例分析

[Etherpot](https://github.com/etherpot)是一个彩票智能合约，与上面提到的示例合约不太相似。Etherpot 的 Soloidity 代码可以在这里找到：[lotto.sol](https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol)。这个合约的主要缺点是对块哈希的不当使用（只有最后 256 个块的哈希值是可用的，请参阅 Aakil Fernandes 关于 Etherpot 如何正确实现的[帖子](http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks)。然而，这份合约也受到未经检查的 Call 返回值的影响。

注意lotto.sol 的 行[80] 上的函数 cash() ：
```
	function cash(uint roundIndex, uint subpotIndex){
        var subpotsCount = getSubpotsCount(roundIndex);
        if(subpotIndex>=subpotsCount)
            return;
        var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);
        if(decisionBlockNumber>block.number)
            return;
        if(rounds[roundIndex].isCashed[subpotIndex])
            return;
        //Subpots can only be cashed once. This is to prevent double payouts
        var winner = calculateWinner(roundIndex,subpotIndex);    
        var subpot = getSubpot(roundIndex);
        winner.send(subpot);
        rounds[roundIndex].isCashed[subpotIndex] = true;
        //Mark the round as cashed
}
```

请注意，在[21]行，发送函数的返回值没有被检查，然后下一行设置了一个布尔值，表示已经向赢家发送了属于他们的奖金。这个错误可能引发一种状态，即赢家没有收到他们的 Ether，但是合约状态表明赢家已经得到了支付。
这个错误的更严重的版本发生在[King of the Ether](https://www.kingoftheether.com/thrones/kingoftheether/index.html)。已经有人写出一篇优秀的安全检验报告，详细介绍了一个未经检查的send()失败交易可以如何用于攻击合约。


#### 修复方案

只要有可能，使用 transfer() 功能，而不是 send() ，因为，如果外部交易回滚， transfer() 会触发回滚。如果需要使用 send() ，请务必检查返回值。

如果实在是需要使用send()，检查send()返回值是否转账成功，成功后再做其他操作：
```
function sendToWinner() public {
	require(!payedOut);
	if(winner.send(winAmount)){
		payedOut = true;
	}else{throw;}
    	}
```
#### 修复方案

### An Attack Vector on Approve/TransferFrom Methods

#### 漏洞描述

在本章节中，我们描述了在标准的ERC20以太坊代币API一个可能的攻击向量。这是对API本身的攻击，而不是在任何特定的代币合约实现上，因此所有符合ERC20实现的代币智能合约都是潜在脆弱的。该方法使用由ERC20定义的approve and transferFrom方法来实现。我们还对如何使用当前版本的ERC20 API防止或至少减轻攻击进行了一些思考。我们还建议对Erc20API进行更改，以使所描述的攻击不可能发生。

ERC20定义了一个标准的API，用于以太坊代币智能合约。代币token由以太坊基金会定义。

因此，E20RC被认为是实现所有代币的基本特征的标准方式，使它们与普通的以太坊软件（如Ethereum包）兼容。

ERC20定义了下面两个方法可以被每一个以太坊代币智能合约实现：

```
function transferFrom(address _from, address _to, uint256 _value) returns (bool success)

```

transferFrom方法用来发送_value数量的代币从_from到_to，允许智能合约给您发送代币。REC20提出了下面的API来授权：
```
function approve(address _spender, uint256 _value) returns (bool success)

```

允许_spender从你的账户里面多次转移至多_value的代币，如果这个函数被再次调用，它将会直接覆盖允许剩余的转账数量的_value。


参考：
- [https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.b32yfk54vyg9](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.b32yfk54vyg9)
- []()

#### 漏洞危害

一个发起消息的攻击者可能会转走相比代币合约拥有者允许发起消息的攻击者所能转走代币更多数量的代币token。

#### 产生原理

如下是攻击流程：

用户A使用approve授权给用户B使用100代币额度，后来用户A要改变授权额度为50代币。在更改授权之前，用户A查询用户B是否使用了授权额度的代币，如果查询到B并没有使用之前的额度，则通过approve函数重新授权给用户B新的50代币的额度。


以上过程仅为用户A的操作，于此同时，用户B同样可以进行相关操作：


用户A查询用户B授权的使用情况，确定用户B没有使用授权代币后，用户A发出更改授权额度交易，但在更改交易成功之前，用户B可利用区块链打包消息的机制，发起一个gas数量很大的从用户A转账100代币的交易。


由于用户B发出的交易gas数量大于用户A更改授权额度交易的gas数量，因此矿机先执行用户B的交易，于是用户B将抢先在用户A更改授权额度交易生效之前转走了用户A上次授权的100代币。从而，等到矿机执行了修改50额度的交易后，用户B又可以使用新授权的50代币。


所以，用户A、B上述授权和转账的操作过程将可能产生两种结果：


* 用户A成功的实现了授权额度的更新，用户B只能使用用户A授权的50代币；
* 用户B得到两次次授权，可以使用150代币。


因此，用户在使用approve重新授权过程中可能导致两种不同的执行结果，存在造成多次授权的可能性。


#### 案例分析

此处不做案例分析，因为实现标准的ERC20的代币协议的智能合约都存在此风险。

#### 修复方案

不算漏洞的漏洞：经过上文的分析，我们认为其本质是区块链交易过程的排队机制会造成插队现象，从而引起了操作结果的不唯一性。

那么，既然存在多次授权的隐患，那么有没有规避的办法呢？

答案是：有的，我们针对此问题，给出下面两种规避的方法。 

第一，在更改授权之前，可先通过approve函数设置授权代币数量为0。等到授权为0操作成功后，并查询被授权的用户没有使用过原授权代币，再通过approve函数重新设置授权代币数量，就可以避免多次授权。

```
    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on
    ///  its behalf. This is a modified version of the ERC20 approve function
    ///  to be a little bit safer
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _amount The amount of tokens to be approved for transfer
    /// @return True if the approval was successful
    function approve(address _spender, uint256 _amount) public returns (bool success) {
        require(transfersEnabled);

        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender,0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));

        // Alerts the token controller of the approve function call
        if (isContract(controller)) {
            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));
        }

        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
}
```

第二，建议代币智能合约开发使用increaseApproval和decreaseApproval函数，进行授权更改操作。该功能直接在授权代币数目上面做增减操作，以避免上述问题。

```
/**
   * @dev Increase the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To increment
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _addedValue The amount of tokens to increase the allowance by.
   */
  function increaseApproval(
    address _spender,
    uint256 _addedValue
  )
    public
    returns (bool)
  {
    allowed[msg.sender][_spender] = (
      allowed[msg.sender][_spender].add(_addedValue));
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  /**
   * @dev Decrease the amount of tokens that an owner allowed to a spender.
   * approve should be called when allowed[_spender] == 0. To decrement
   * allowed value is better to use this function to avoid 2 calls (and wait until
   * the first transaction is mined)
   * From MonolithDAO Token.sol
   * @param _spender The address which will spend the funds.
   * @param _subtractedValue The amount of tokens to decrease the allowance by.
   */
  function decreaseApproval(
    address _spender,
    uint256 _subtractedValue
  )
    public
    returns (bool)
  {
    uint256 oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue >= oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
}
```

两种修复方案参考：

- [https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)

## 拒绝服务


**事件回顾**

2016年2月6日至8日The King of the Ether Throne（以下简称KotET）“纷争时代”（Turbulent Age）期间，许多游戏中的退位君王的补偿和未接受款项无法退回用户玩家的钱包.具有讽刺意味的是同年6月，连庞氏骗局GovernMental的合约也遭遇DoS攻击，当时1100以太币是通过使用250万gas交易获得，这笔交易超出了合约能负荷的gas上限，带来交易活动的暂停。

无论是蓄意破坏交易正常流程还是阻塞交易通道，都用到了一个互联网时代已经盛行已久的攻击方式——DoS，也就是我们所说的拒绝服务攻击。这种攻击方式可以让合约执行的正常的交易操作被扰乱，中止，冻结，更严重的是让合约本身的逻辑无法运行。

**何为DoS**

DoS 是DenialOfService，拒绝服务的缩写，从字面上来理解，就是用户所需要的服务请求无法被系统处理。

打个比方来形容DoS，火车站是为大家提供乘车服务的，如果想要DoS火车站的话，方法有很多，可以占用过道不上车，堵住售票点不付钱，阻挠列车员或者司机不让开车，甚至用破坏铁轨等更加极端的手段来影响车站服务的正常运营。

过去针对互联网的DoS有很多种方法，但基本分为三大类：利用软件实现的缺陷，利用协议的漏洞，利用资源压制。

此外还有DDoS，称为分布式DoS，其区别就是攻击者利用远程操控的计算机同时向目标发起进攻，在上面的比喻中可以理解为雇佣了几百个地痞流氓来做同样的事影响车站的运作。

**智能合约DoS攻击原理分析及相应漏洞修复**

无处不在的DoS当然也会对基于Solidity语言的以太坊合约产生威胁。针对智能合约的DoS攻击属于利用协议漏洞进行的手段，具体的攻击方法有三种[4]，其目的是使合约在一段时间或者永久无法正常运行。通过DoS攻击，可以使合约中的Ether永远无法提取出来，区块成为“冰冻废土”。


### 通过(Unexpected) Revert发动DoS

#### 漏洞描述

DoS 无处不在，在 Solidity 里也是，与其说是拒绝服务漏洞不如简单的说成是“不可恢复的恶意操作或者可控制的无限资源消耗”。如果智能合约的状态改变依赖于外部函数执行的结果，又未对执行一直失败的情况做出防护，那么该智能合约就可能遭受DOS攻击。

#### 漏洞危害

简单的说就是对以太坊合约进行 DoS 攻击，可能导致 Ether 和 Gas 的大量消耗以及无限循环、递归栈耗尽等拒绝服务风险。更严重的是让原本的合约代码逻辑无法正常运行。


#### 产生原理

下面一个例子（代码改自 DASP 中例子）：

```
pragma solidity ^0.4.10;

contract PresidentOfCountry {
    address public president;
    uint256 price;

    function PresidentOfCountry(uint256 _price) {
        require(_price > 0);
        price = _price;
        president = msg.sender;
    }

    function becomePresident() payable {
        require(msg.value >= price); // must pay the price to become president
        president.transfer(price);   // we pay the previous president
        president = msg.sender;      // we crown the new president
        price = price * 2;           // we double the price to become president
    }
}

```

一个简单的类似于 KingOfEther 的合约，按合约的正常逻辑任何出价高于合约当前 price 的都能成为新的president，原有合约里的存款会返还给上一人 president，并且这里也使用了 transfer()来进行Ether转账，看似没有问题的逻辑，但不要忘了，以太坊中有两类账户类型，如果发起becomePresident() 调用的是个合约账户，并且成功获取了 president，如果其 fallback() 函数恶意进行了类似 revert() 这样主动跑出错误的操作，那么其他账户也就无法再正常进行 becomePresident 逻辑成为president了。

简单的攻击代码如下：

```

contract Attack {
    function () payable{ revert(); }

    function Attack(address _target) payable {
        _target.call.value(msg.value)(bytes4(keccak256("becomePresident()")));
    }
}

```

#### 案例分析

暂时还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

如果需要对外部函数调用的结果进行处理才能进入新的状态，请考虑外部调用可能一直失败的情况，也可以添加基于时间的操作，防止外部函数调用一直无法满足require判断。

### 通过区块Gas Limit发动DOS

#### 漏洞描述

一次性向所有人转账，很可能会导致达到以太坊区块gas limit的上限。以太坊规定了每一个区块所能花费的gas limit，如果超过交易便会失败。

#### 漏洞危害

即使没有故意的攻击，这也可能导致问题。然而，最为糟糕的是如果gas的花费被攻击者操控。在先前的例子中，如果攻击者增加一部分收款名单，并设置每一个收款地址都接收少量的退款。这样一来，更多的gas将会被花费从而导致达到区块gas limit的上限，整个转账的操作也会以失败告终。

#### 产生原理

如以下简化版案例合约所示：

```
pragma solidity ^0.4.24;

contract DistributeTokens{
    
    address public owner; // gets set somewhere
    address[] investors; // array of investors
    uint256[] investorsTokens; // the amount of tokens each investor gets
    
    // ... extra functionality ,including transfertoken()
    
    function invest() public payable{
        
        investors.push(msg.sender);
        investorsTokens.push(msg.value*5);
        
    }
    
    function distribute() public{
        
        require(owner==msg.sender); // only owner
        for(uint i = 0;i<investors.length;i++){
            // here transfertoken(to, amount) transfer "amount" of tokens to the address "to"
            transfertoken(investors[i],investorsTokens[i]);
        }
    }
    function transfertoken(address add, uint amount) public{
        require(owner==msg.sender); // only owner
        // do something
    }
    
}

```

这个案例合约遍历可被人为操纵的investors[]数组。攻击者可以创建许多账户，使得investors[]数组变的很大，使得执行for循环所消耗的gas超过块gas极限，使得distribute函数一直处于out-of-gas（OOG）状态，而一直无法执行成功，合约正常功能实现受到影响。

#### 案例分析

暂时还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

合约不应该循环对可以被外部用户人为操纵的数据结构进行批量操作，建议使用取回模式而不是发送模式，每个投资者可以使用withdrawFunds取回自己应得的代币；

如果实在必须通过遍历一个变长数组来进行转账，最好估计完成它们大概需要多少个区块以及多少笔交易。然后你还必须能够追踪得到当前进行到哪以便当操作失败时从那里开始恢复，举个例子：

```

struct Payee {
address addr;
uint256 value;

}
Payee payees[];

uint256 nextPayeeIndex;

function payOut() {
uint256 i = nextPayeeIndex;
while (i < payees.length && msg.gas > 200000) {
payees[i].addr.send(payees[i].value);
i++;
}
nextPayeeIndex = i;

}

```

如上所示，你必须确保在下一次执行payOut()之前另一些正在执行的交易不会发生任何错误。如果必须，请使用上面这种方式来处理。


### 死循环类型拒绝服务

#### 漏洞描述

另外， 我们联系之前提到的Owner权限过大，“超中心化”的问题，发现目前很多代币合约都有一个Owner账户，其拥有开启/暂停交易的权限，如果对owner保管不善，代币合约可能被一直冻结交易。

#### 漏洞危害

导致非主观的拒绝服务攻击。

#### 产生原理

例如如下owner权限中的功能：

```

    bool public isFinalized=false;
    address public owner; // gets some where
    
    function finalize() public {
        require(owner == msg.sender);
        isFinalized=true;
    }
    
    // ... extra ICO functionality
    
    // overload transfer function
    function transfer(address _to,uint256 _value) returns(bool){
        require(isFinalized);
        super.transfer(_to,_value)
    }
    
```

此owner权限的局限性在于，在ICO结束后，如果特权用户丢失其私钥或变为非活动状态，Owner无法调用finalize()，用户则一直不可以发送代币，即令牌生态系统的整个操作取决于一个地址。

#### 案例分析

暂时还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

可以设置多个拥有owner权限的地址，或者设置暂停交易的期限，超过期限就可以恢复交易，如：require(msg.sender == owner || now > unlockTime)。

### 死循环类型拒绝服务

#### 漏洞描述

#### 漏洞危害

#### 产生原理

#### 案例分析

#### 修复方案


**总结**

针对这些常见的DOS攻击漏洞，我们需要做到：

- 对于调用外部函数的代码一定要考虑周全，对于例外情况的判定要加入代码中。

- 遍历变长数组来逐个支付的方法需要全方位考虑和估计。合约中不应存在外部人员操纵的成分。

- 强调再三的去中心化特征也应该应用到Owner权限这个概念上来。

## 函数误用

### Bad Randomness – 可预测的随机处理

#### 漏洞描述

伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。

#### 漏洞危害

如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行“作弊”。


#### 产生原理

摘自 DASP 的代码块：

```
uint256 private seed;
function play() public payable {
    require(msg.value >= 1 ether);
    iteration++;
    uint randomNumber = uint(keccak256(seed + iteration));
    if (randomNumber % 2 == 0) {
        msg.sender.transfer(this.balance);
    }
}
```

这里 seed 变量被标记为了私有变量，前面有说过链上的数据都是公开的，seed 的值可以通过扫描与该合约相关的 TX 来获得。获取 seed 值后，同样的 iteration 值也是可以得到的，那么整个 uint(keccak256(seed + iteration)) 的值就是可预测的了。

就 DASP 里面提到的，还有一些合约喜欢用 block.blockhash(uint blockNumber) returns (bytes32) 来获取一个随机哈希，但是这里切记不能使用 block.number 也就是当前块号来作为 blockNumber 的值，因为在官方文档中明确写了：
block.blockhash(uint blockNumber) returns (bytes32): hash of the given block – only works for 256 most recent blocks excluding current

意思是说 block.blockhash() 只能使用近 256 个块的块号来获取 Hash 值，并且还强调了不包含当前块，如果使用当前块进行计算 block.blockhash(block.numbber) 其结果始终为 0x0000000.....：



同样的也不能使用 block.timestamp, now 这些可以由矿工控制的值来获取随机数。


#### 案例分析

暂时还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

一切链上的数据都是公开的，想要获取一个靠谱的随机数，使用链上的数据看来是比较难做到的了，这里有一个独立的项目 Oraclize 被设计来让 Smart Contract 与互联网进行交互，有兴趣的同学可以深入了解一下。（附上基于 Oraclize 的随机数获取方法 [randomExample](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)）

参考链接：
- [https://github.com/oraclize/ethereum-api](https://github.com/oraclize/ethereum-api)
- [https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)

### 不期而至的Ether

#### 漏洞描述

通常，当 Ether 发送到合约时，它必须执行回退功能或合约中描述的其他功能。这里有两个例外，合约可能会收到了 Ether 但并不会执行任何函数。通过收到以太币来触发代码的合约，对强制将以太币发送到某个合约这类攻击是非常脆弱的。

关于这方面的进一步阅读，请参阅[如何保护您的智能合约：6](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834) 和 [Solidity security patterns - forcing ether to a contract](http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html)

一种常用的防御性编程技术对于执行正确的状态转换或验证操作很有用，它是不变量检查（Invariant-checking）。该技术涉及定义一组不变量（不应改变的度量或参数），并且在单个（或多个）操作之后检查这些不变量保持不变。这基本上是很好的设计，保证受到检查的不变量在实际上保持不变。不变量的一个例子是发行量固定的 [ERC20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md) 代币合约的 ` totalSupply ` 。不应该有函数能修改此不变量，因此可以在该 ` transfer() ` 函数中添加一个检查以确保 ` totalSupply ` 保持未修改状态，确保函数按预期工作。

不管智能合约中规定的规则如何，有一个量，特别容易诱导开发人员将其当作明显的“不变量”来使用，但它在事实上是可以由外部用户来操纵的，那便是合约中存储的 Ether 数量。通常，开发人员刚开始学习 Solidity 时，他们有一种误解，认为合约只能通过 ` payable ` 函数接受或获得 Ether。这种误解可能会导致合约对其内部的 ETH 余额有错误的假设，进而导致一系列的漏洞。此漏洞的明显信号是（不正确地）使用 ` this.balance ` 。正如我们将看到的，错误地使用 ` this.balance ` 会导致这种类型的严重漏洞。

有两种方式可以将 Ether（强制）发送给合约，而无需使用 ` payable ` 函数或执行合约中的任何代码。这些在下面列出。

**自毁**

任何合约都能够实现该 [` selfdestruct(address) `](http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct) 功能，该功能从合约地址中删除所有字节码，并将所有存储在那里的 Ether 发送到参数指定的地址。如果此指定的地址也是合约，则不会调用任何功能（包括故障预置）。因此，使用 ` selfdestruct() ` 函数可以无视目标合约中存在的任何代码，强制将 Ether 发送给任一目标合约，包括没有任何可支付函数的合约。这意味着，任何攻击者都可以创建带有 ` selfdestruct() ` 函数的合约，向其发送 Ether，调用 ` selfdestruct(target) ` 并强制将 Ether 发送至 ` target ` 合约。Martin Swende 有一篇出色的[博客文章](http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html)描述了自毁操作码（Quirk＃2）的一些诡异操作，并描述了客户端节点如何检查不正确的不变量，这可能会导致相当灾难性的客户端问题。

**预先发送的 Ether**

合约不使用 ` selfdestruct() ` 函数或调用任何 payable 函数仍可以接收到 Ether 的第二种方式是把 Ether 预装进合约地址。合约地址是确定性的，实际上地址是根据创建合约的地址及创建合约的交易 Nonce 的哈希值计算得出的，即下述形式： ` address = sha3(rlp.encode([account_address,transaction_nonce]) ` 请参阅 [Keyless Ether](https://github.com/sigp/solidity-security-blog#keyless-eth) 在这一点上的一些有趣用例）。这意味着，任何人都可以在创建合约之前计算出合约地址，并将 Ether 发送到该地址。当合约确实创建时，它将具有非零的 Ether 余额。

#### 漏洞危害

造成不可预估的后果，可能会导致合约无法正常执行，也可以会导致超额转账等一些未知结果到漏洞。

#### 产生原理

根据上述知识，我们来探讨一些可能出现的缺陷。
考虑过于简单的合约，

EtherGame.sol：

```solidity
contract EtherGame {
    
    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 
    
    mapping(address => uint) redeemableEther;
    // users pay 0.5 ether. At specific milestones, credit their accounts
    function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }
    
    function claimReward() public {
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }    
```

这个合约代表一个简单的游戏（自然会引起[条件竞争（Race-conditions）](#条件竞争非法预先交易)），玩家可以将 ` 0.5 ether ` 发送给合约，希望成为第一个达到三个里程碑之一的玩家。里程碑以 Ether 计价。当游戏结束时，第一个达到里程碑的人可以获得合约的部分 Ether。当达到最后的里程碑（10 Ether）时，游戏结束，用户可以申请奖励。

EtherGame 合约的问题出自在 [14] 行（以及相关的 [16] 行）和 [32] 行中对 ` this.balance ` 的错误使用。一个调皮的攻击者可以通过（上面讨论过的） ` selfdestruct() ` 函数强行发送少量的以太，比如 ` 0.1 ether `，以防止未来的玩家达到一个里程碑。由于所有合法玩家只能发送 ` 0.5 ether ` 增量，而合约收到了 ` 0.1 ether ` ，合约的 ` this.balance ` 不再是半个整数。这会阻止 [18]、[21]和[24] 行的所有条件成立。

更糟糕的是，一个因错过了里程碑而复仇心切的攻击者可能会强行发送 ` 10 ether ` （或者会将合约的余额推到高出 ` finalMileStone ` 的数量），这将永久锁定合约中的所有奖励。这是因为 ` claimReward() ` 函数总是会回弹，因为 [32] 行中的要求（即 ` this.balance ` 大于 ` finalMileStone ` ）。

#### 案例分析

还没有找到该漏洞在真实世界中被利用的例子。然而，在 [Underhanded Solidity 竞赛](https://github.com/Arachnid/uscc/tree/master/submissions-2017/)中出现了一些可利用该漏洞的合约的例子。

#### 修复方案

这个漏洞通常是由于错误运用 ` this.balance ` 而产生的。如果可能，合约逻辑应该避免依赖于合约余额的确切值，因为它可以被人为地操纵。如果应用基于 ` this.balance ` 函数的逻辑语句，请确保考虑到了飞来横 Ether。

如果需要存储 Ether 的确定值，则应使用自定义变量来获得通过可支付函数获得的增量，以安全地追踪储存 Ether 的值。这个变量不应受到通过调用 ` selfdestruct() ` 强制发送的 Ether 的影响。

考虑到这一点，修正后的EtherGame合约版本可能如下所示：

```solidity
contract EtherGame {
    
    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 
    uint public depositedWei;
    
    mapping (address => uint) redeemableEther;
    
    function play() public payable {
        require(msg.value == 0.5 ether);
        uint currentBalance = depositedWei + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        depositedWei += msg.value;
        return;
    }
    
    function claimReward() public {
        // ensure the game is complete
        require(depositedWei == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }    
```

在这里，我们刚刚创建了一个新变量， ` depositedEther `，它跟踪已知的 Ether 存储量，并且这也是我们执行需求和测试时用到的变量。请注意，我们不再参考 ` this.balance `。

### Tx.Origin身份验证

#### 漏洞描述

Solidity具有一个全局变量，tx.origin它遍历整个调用栈并返回最初发送调用（或事务）的帐户的地址。在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。
有关进一步阅读，请参阅Stack Exchange Question，Peter Venesses博客和Solidity - Tx.Origin攻击。

#### 漏洞危害


授权用户使用该tx.origin变量的合约通常容易受到网络钓鱼攻击的攻击，这可能会诱使用户对易受攻击的合约执行身份验证操作。

#### 产生原理

考虑简单的合约，

```solidity
contract Phishable {
    address public owner;
    
    constructor (address _owner) {
        owner = _owner; 
    }
    
    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        require(tx.origin == owner);
        _recipient.transfer(this.balance); 
    }
}
```

请注意，在[11]行中，此合约授权withdrawAll()使用该功能tx.origin。该合约允许攻击者创建表单的攻击合约，

```solidity
import "Phishable.sol";

contract AttackContract { 
    
    Phishable phishableContract; 
    address attacker; // The attackers address to receive funds.

    constructor (Phishable _phishableContract, address _attackerAddress) { 
        phishableContract = _phishableContract; 
        attacker = _attackerAddress;
    }
    
    function () { 
        phishableContract.withdrawAll(attacker); 
    }
}
```

为了利用这个合约，攻击者会部署它，然后说服Phishable合约的所有者发送一定数量的合约。攻击者可能把这个合约伪装成他们自己的私人地址，社工受害人发送某种形式的交易到地址。受害者除非注意，否则可能不会注意到攻击者地址上有代码，或者攻击者可能将其作为多重签名钱包或某些高级存储钱包传递。

在任何情况下，如果受害者向AttackContract地址发送了一个事务（有足够的gas），它将调用fallback功能，后者又调用该参数withdrawAll()的Phishable合约功能attacker。这将导致所有资金从Phishable合约中撤回到attacker地址。这是因为，首先初始化呼叫的地址是受害者（即owner中的Phishable合约）。因此，tx.origin将等于owner和require所述的上线[11] Phishable合约会通过。

#### 案例分析

还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

tx.origin不应该用于智能合约授权。这并不是说该tx.origin变量不应该被使用。它确实在智能合约中有一些合法用例。例如，如果有人想要拒绝外部合约调用当前合约，他们可以实现一个requirefrom require(tx.origin == msg.sender)。这可以防止用于调用当前合约的中间合约，将合约限制为常规无代码地址。


# 参考
* [参考文献/更多阅读列表](#参考文献更多阅读列表)

  - [Ethereum Wiki - Safety](https://github.com/ethereum/wiki/wiki/Safety)
  - [Solidity Docs - Security Considerations](solidity.readthedocs.io/en/latest/security-considerations.html)
  - [Consensus - Ethereum Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices)
  - [History of Ethereum Security Vulnerabilities, Hacks and Their Fixes](https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes)
  - [Decentralized Application Security Project (DASP) Top 10 of 2018](http://www.dasp.co/)
  - [A Survey of attacks on Ethereum Smart Contracts](https://eprint.iacr.org/2016/1007.pdf)
  - [Ethereum Smart Contract Security](https://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8)
  - [Lessons Learnt from the Underhanded Solidity Contest](https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1)
  - [https://cloud.tencent.com/developer/news/285408](https://cloud.tencent.com/developer/news/285408)


