# 智能合约常见安全漏洞及修复方案 V1.0
author: bobby
## 前言介绍
最近区块链漏洞不要太火，什么交易所用户被钓鱼导致 APIKEY 泄漏，代币合约出现整数溢出漏洞致使代币归零， MyEtherWallet 遭 DNS 劫持致使用户 ETH 被盗等等。频频爆出的区块链安全事件，越来越多的安全从业者将目标转到了 Blockchain 上。本文将从以太坊智能合约的一些特殊机制说起，详细地剖析已发现各种漏洞类型，对每一种漏洞类型都会提供一段简单的合约代码来对漏洞成因和攻击方法进行说明。

### 使用对象
    本规范的读者及使用对象主要为智能合约开发者、测试、安全相关人员。

### 使用目标
1、智能合约开发者能够了解智能合约常见的安全漏洞和修复方案。

2、测试和安全相关人员能够对智能合约进行安全测试，包括源码审计方法和渗透测试方法。

3、团队管理者等其他管理人员对目前主要的智能安全漏洞有一定的认识。
## 目录
### 溢出
* 漏洞描述
* 漏洞危害
* 产生原理
* 案例分析
* 修复方案
### 越权访问


### 信息泄漏

### 逻辑错误

### 拒绝服务

### 函数误用

## 漏洞列表
### 溢出
#### 整数溢出
* 漏洞描述

以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整型变量只能有一定范围的数字表示。A uint8例如，只能存储在范围[0,255]的数字。试图存储256到一个uint8将导致0。如果不注意，如果不选中用户输入并执行计算，导致数字超出存储它们的数据类型的范围，则可以利用Solidity中的变量。

当执行操作需要固定大小的变量来存储超出变量数据类型范围的数字（或数据）时，会发生溢出。

* 漏洞危害

可能导致合约失效、无限发币等风险。例如攻击者就可以利用这个漏洞，可无限制的将任意账户的代币token转到指定的账户(_to)，从而导致所有持有次代币的账户都有可能被盗取，严重危害了用户的财产安全。

* 产生原理
  * 上溢错误
  
  	数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0	  到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	+0x000000000000000000000000000000000001
	=0x000000000000000000000000000000000000
	数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0	  到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	+0x000000000000000000000000000000000001
    =0x000000000000000000000000000000000000
    
  * 下溢错误
  	
    好了，看看另个极端，也就是下溢错误。Over跟under是反义词。这俩错误也是反着来的。
	uint8只能取0到255之间的值，还记得吧？ 那么，考虑以下代码。
	unint8 a = 0;
	a–;
	这就是下溢，后果是a的最大可能值是255。
	出现在Solidity智能合约中，就是这：
	0x000000000000000000000000000000000000
	–0x000000000000000000000000000000000001
	=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

* 案例分析 BEC智能合约致命漏洞
  * 安全事件
  
	最近，智能合约漏洞很火。让我们再来看一下4月22日BeautyChain（BEC）的智能合约中一个毁灭性的漏洞。	BeautyChain团队宣布，BEC代币在4月22日出现异常。攻击者通过智能合约漏洞成功转账了10^58 BEC到两个指	 定的地址。
    
	具体交易详情[https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f](https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f)
	攻击者到底是怎么攻击的？为什么能转账这么大的BEC？
    
  * 智能合约代码
  
	首先我们来看BEC转账的智能合约代码
    
    ```Solidity
    
    function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused 		returns (bool) {
        uint cnt = _receivers.length;
        uint256 amount = uint256(cnt) * _value;
        require(cnt > 0 && cnt <= 20);
        require(_value > 0 && balances[msg.sender] >= amount);
     
        balances[msg.sender] = balances[msg.sender].sub(amount);
        for (uint i = 0; i < cnt; i++) {
            balances[_receivers[i]] = balances[_receivers[i]].add(_value);
            Transfer(msg.sender, _receivers[i], _value);
        }
        return true;
     }
    
    ```
    
    以上的代码是Solidity语言，是一门面向合约的，为实现智能合约而创建的高级编程语言。
    
  * 代码解读
  
	知道了这几个变量类型，下面我们一行一行的来读这段代码。
    
	第一行
    
	function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused 		returns (bool)
	函数有两个参数:
    _receivers —————转账接收人，address类型的变量数组，是一个160位的值。
    _value ———————-转账数量，uint256的状态变量，256位的无符号整数。
    定义函数batchTransfer，功能主要是实现转账，接收两个参数，定义了参数的取值范围。
    
    第二行
    
    uint cnt = _receivers.length;
    计算接收人地址对应地址数组的长度，即转账给多少人。
    
    第三行
    
    uint256 amount = uint256(cnt) * _value;
    把unit类型的cnt参数值强制转换为uint256然后乘以转账数量_value 并赋值给uint256类型的amount变量。
    
    第四行
    
    require(cnt > 0 && cnt <= 20);
    require函数
    require的入参判定为 false，则终止函数，恢复所有对状态和以太币账户的变动，并且也不会消耗 gas 。 判	  断cnt是否大于0且cnt是否小于等于20
    
    第五行
    
    require(_value > 0 && balances[msg.sender] >= amount);
    参数解读:
    _value—————————————转账数量
    balances[msg.sender]————-转账人余额
    amount————————————转账总数量
    判断_value是否大于0且转账人的余额balances[msg.sender]大于等于转账总金额amount

    第六行

    balances[msg.sender] = balances[msg.sender].sub(amount);
    计算转账人的余额，使用当前余额balances[msg.sender]减去转账总数量

    第七行

    for (uint i = 0; i < cnt; i++) {
    这里是一个循环，循环次数为cnt（遍历转账地址）

    第八行

    balances[_receivers[i]] = balances[_receivers[i]].add(_value);
    当i有具体的值时，balances[_receivers[i]]表示转账接收人，这里是表示转账人给转账接收人_value数量的币。

    第九行

    Transfer(msg.sender, _receivers[i], _value);
    保存转账记录

    第十行

    return true;
    函数返回为True
    
  * 代码流程
    
    OK，我们读了完整的代码，接下来请看一个流程图

  * 攻击过程

	其实，他只是细心了一点，所使用的攻击方法并不高明啊，你且听我慢慢道来，注意看，别走神啊。
    
  * 交易详情
  
	我们首先看这笔详细的交易：
    

    
    我们从图可以看到转账接收人有两个地址，即balances[_receivers]:
    000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033
    0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7
    转账数量为_value:
    8000000000000000000000000000000000000000000000000000000000000000（十六进制）
    转10进制为
    57896044618658097711785492504343953926634992332820282019728792003956564819968
    OK，接下来我们来走函数流程

    第一行

    function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool)

    正常执行

    第二行

    uint cnt = _receivers.length
    由于这里有两个转账接收人地址，address数组长度为2，所以cnt为2，类型为uint

    第三行

    uint256 amount = uint256(cnt) * _value;   
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968
    cnt=2
    两者相乘得到amount，类型为uint256
    即amount=115792089237316195423570985008687907853269984665640564039457584007913129639936
    考试重点用上了，记不住的同学去前面看看。
    amount的类型为uint256，那么按照理论，它的最大取值是0到2^256减1，即
    115792089237316195423570985008687907853269984665640564039457584007913129639935
    所以amount瞬间从115792089237316195423570985008687907853269984665640564039457584007913129639936变成了0
    第三行得到的结果：amount=0

    第四行

    require(cnt > 0 && cnt <= 20);
    cnt=2，2肯定大于0，2当然也小于等于20
    所以这个条件成立，require函数返回值为True。

    第五行

    require(_value > 0 && balances[msg.sender] >= amount);
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968
    _value肯定是大于0，转账人的余额balances[msg.sender]肯定是大于等于0的。
    所以这个条件同样成立，require函数返回值为True。

    第六行

    balances[msg.sender] = balances[msg.sender].sub(amount); 前面的条件都成立，那么代码会执行到这。
    这行代码是求转账人转完账以后剩下的余额，amount为0 ，那么转账人的余额其实没变！！！
    第七行
    for (uint i = 0; i < cnt; i++)
    cnt=2，该行代码表示执行两次后面的操作
    第八行
        balances[_receivers[i]] = balances[_receivers[i]].add(_value);
        i=0时，转账接收人balances[_receivers[0]]的余额加_value
        i=1时，转账接收人balances[_receivers[1]]的余额加_value
    看到这里其实我们就很明白了吧。
    攻击者给以下两个转账接收人
        000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033
        0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7
    转了
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968个币
    更可恶的是，攻击者执行完这个操作，转账人的余额根本没变，看代码第六行的执行结果。

    第九行

    Transfer(msg.sender, _receivers[i], _value);
    这里只是把上面两个转账记录保存。

    第十行

    return true;
    函数返回为True
    
    参考链接：[https://blog.csdn.net/Fly_hps/article/details/80732159](https://blog.csdn.net/Fly_hps/article/details/80732159)

* 修复方案
  
为了避免整数溢出，可以将条件判断改为比较操作，例如：require(balances[msg.sender] > _amount)，     这样就不会执行算术操作进行进行逻辑判断，一定程度上避免了整数溢出的发生。

为了防止整数溢出的发生，一方面可以在算术逻辑前后进行验证，另一方面可以直接使用 OpenZeppelin 维护的一套智能合约函数库中的 SafeMath 来处理算术逻辑。[OppenZepplin](https://github.com/OpenZeppelin/zeppelin-solidity) 在构建和审计 Ethereum 社区可以利用的安全库方面做得非常出色。特别是，他们的 [SafeMath](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol) 是一个用来避免上溢/下溢漏洞的参考或库。
```solidity
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b); 
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b; 
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```

### 越权访问


### 信息泄漏

### 逻辑错误
#### Reetrancy攻击
* 漏洞描述



* 漏洞危害



* 产生原理



* 案例分析



* 修复方案

### 拒绝服务

### 函数误用
#### Bad Randomness – 可预测的随机处理
* 漏洞描述

伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。

* 漏洞危害

如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行“作弊”。


* 产生原理

摘自 DASP 的代码块：

```
uint256 private seed;
function play() public payable {
    require(msg.value >= 1 ether);
    iteration++;
    uint randomNumber = uint(keccak256(seed + iteration));
    if (randomNumber % 2 == 0) {
        msg.sender.transfer(this.balance);
    }
}
```

这里 seed 变量被标记为了私有变量，前面有说过链上的数据都是公开的，seed 的值可以通过扫描与该合约相关的 TX 来获得。获取 seed 值后，同样的 iteration 值也是可以得到的，那么整个 uint(keccak256(seed + iteration)) 的值就是可预测的了。

就 DASP 里面提到的，还有一些合约喜欢用 block.blockhash(uint blockNumber) returns (bytes32) 来获取一个随机哈希，但是这里切记不能使用 block.number 也就是当前块号来作为 blockNumber 的值，因为在官方文档中明确写了：
block.blockhash(uint blockNumber) returns (bytes32): hash of the given block – only works for 256 most recent blocks excluding current

意思是说 block.blockhash() 只能使用近 256 个块的块号来获取 Hash 值，并且还强调了不包含当前块，如果使用当前块进行计算 block.blockhash(block.numbber) 其结果始终为 0x0000000.....：



同样的也不能使用 block.timestamp, now 这些可以由矿工控制的值来获取随机数。


* 案例分析



* 修复方案

一切链上的数据都是公开的，想要获取一个靠谱的随机数，使用链上的数据看来是比较难做到的了，这里有一个独立的项目 Oraclize 被设计来让 Smart Contract 与互联网进行交互，有兴趣的同学可以深入了解一下。（附上基于 Oraclize 的随机数获取方法 [randomExample](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)）

参考链接：
      - [https://github.com/oraclize/ethereum-api](https://github.com/oraclize/ethereum-api)
      - [https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)












## 参考
* [参考文献/更多阅读列表](#参考文献更多阅读列表)

  - [Ethereum Wiki - Safety](https://github.com/ethereum/wiki/wiki/Safety)
  - [Solidity Docs - Security Considerations](solidity.readthedocs.io/en/latest/security-considerations.html)
  - [Consensus - Ethereum Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices)
  - [History of Ethereum Security Vulnerabilities, Hacks and Their Fixes](https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes)
  - [Decentralized Application Security Project (DASP) Top 10 of 2018](http://www.dasp.co/)
  - [A Survey of attacks on Ethereum Smart Contracts](https://eprint.iacr.org/2016/1007.pdf)
  - [Ethereum Smart Contract Security](https://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8)
  - [Lessons Learnt from the Underhanded Solidity Contest](https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1)


