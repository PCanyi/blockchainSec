# 智能合约常见安全漏洞及修复方案 V1.0
author: bobby
## 前言介绍
最近区块链漏洞不要太火，什么交易所用户被钓鱼导致 APIKEY 泄漏，代币合约出现整数溢出漏洞致使代币归零， MyEtherWallet 遭 DNS 劫持致使用户 ETH 被盗等等。频频爆出的区块链安全事件，越来越多的安全从业者将目标转到了 Blockchain 上。本文将从以太坊智能合约的一些特殊机制说起，详细地剖析已发现各种漏洞类型，对每一种漏洞类型都会提供一段简单的合约代码来对漏洞成因和攻击方法进行说明。

### 使用对象
    本规范的读者及使用对象主要为智能合约开发者、测试、安全相关人员。

### 使用目标
1、智能合约开发者能够了解智能合约常见的安全漏洞和修复方案。

2、测试和安全相关人员能够对智能合约进行安全测试，包括源码审计方法和渗透测试方法。

3、团队管理者等其他管理人员对目前主要的智能安全漏洞有一定的认识。
## 目录
### 溢出
* 漏洞描述
* 漏洞危害
* 产生原理
* 案例分析
* 修复方案
### 越权访问
### 信息泄漏
### 逻辑错误
### 拒绝服务
### 函数误用

## 漏洞列表
### 溢出
#### 整数溢出
* 漏洞描述

以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整型变量只能有一定范围的数字表示。A uint8例如，只能存储在范围[0,255]的数字。试图存储256到一个uint8将导致0。如果不注意，如果不选中用户输入并执行计算，导致数字超出存储它们的数据类型的范围，则可以利用Solidity中的变量。

当执行操作需要固定大小的变量来存储超出变量数据类型范围的数字（或数据）时，会发生溢出。

* 漏洞危害

可能导致合约失效、无限发币等风险。例如攻击者就可以利用这个漏洞，可无限制的将任意账户的代币token转到指定的账户(_to)，从而导致所有持有次代币的账户都有可能被盗取，严重危害了用户的财产安全。

* 产生原理
  * 上溢错误
  
  	数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0	  到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	+0x000000000000000000000000000000000001
	=0x000000000000000000000000000000000000
	数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0	  到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	+0x000000000000000000000000000000000001
    =0x000000000000000000000000000000000000
    
  * 下溢错误
  	
    好了，看看另个极端，也就是下溢错误。Over跟under是反义词。这俩错误也是反着来的。
	uint8只能取0到255之间的值，还记得吧？ 那么，考虑以下代码。
	unint8 a = 0;
	a–;
	这就是下溢，后果是a的最大可能值是255。
	出现在Solidity智能合约中，就是这：
	0x000000000000000000000000000000000000
	–0x000000000000000000000000000000000001
	=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

* 案例分析

* 修复方案
  
为了避免整数溢出，可以将条件判断改为比较操作，例如：require(balances[msg.sender] > _amount)，     这样就不会执行算术操作进行进行逻辑判断，一定程度上避免了整数溢出的发生。

为了防止整数溢出的发生，一方面可以在算术逻辑前后进行验证，另一方面可以直接使用 OpenZeppelin 维护的一套智能合约函数库中的 SafeMath 来处理算术逻辑。[OppenZepplin](https://github.com/OpenZeppelin/zeppelin-solidity) 在构建和审计 Ethereum 社区可以利用的安全库方面做得非常出色。特别是，他们的 [SafeMath](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol) 是一个用来避免上溢/下溢漏洞的参考或库。
```solidity
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b); 
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b; 
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```








## 参考
* [参考文献/更多阅读列表](#参考文献更多阅读列表)

  - [Ethereum Wiki - Safety](https://github.com/ethereum/wiki/wiki/Safety)
  - [Solidity Docs - Security Considerations](solidity.readthedocs.io/en/latest/security-considerations.html)
  - [Consensus - Ethereum Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices)
  - [History of Ethereum Security Vulnerabilities, Hacks and Their Fixes](https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes)
  - [Decentralized Application Security Project (DASP) Top 10 of 2018](http://www.dasp.co/)
  - [A Survey of attacks on Ethereum Smart Contracts](https://eprint.iacr.org/2016/1007.pdf)
  - [Ethereum Smart Contract Security](https://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8)
  - [Lessons Learnt from the Underhanded Solidity Contest](https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1)


