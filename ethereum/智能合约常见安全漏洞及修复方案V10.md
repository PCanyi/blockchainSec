<center><font size="6">智能合约常见安全漏洞及修复方案 V1.0</font></center>

author: bobby

# 智能合约常见安全漏洞及修复方案 V1.0

# 前言介绍

最近区块链漏洞不要太火，什么交易所用户被钓鱼导致 APIKEY 泄漏，代币合约出现整数溢出漏洞致使代币归零， MyEtherWallet 遭 DNS 劫持致使用户 ETH 被盗等等。频频爆出的区块链安全事件，越来越多的安全从业者将目标转到了 Blockchain 上。本文将从以太坊智能合约的一些特殊机制说起，详细地剖析已发现各种漏洞类型，对每一种漏洞类型都会提供一段简单的合约代码来对漏洞成因和攻击方法进行说明。

## 使用对象

本规范的读者及使用对象主要为智能合约开发者、测试、安全相关人员。

## 使用目标
1、智能合约开发者能够了解智能合约常见的安全漏洞和修复方案。

2、测试和安全相关人员能够对智能合约进行安全测试，包括源码审计方法和渗透测试方法。

3、团队管理者等其他管理人员对目前主要的智能安全漏洞有一定的认识。
# 目录
## 溢出漏洞
* [整数溢出](#整数溢出)
## 越权访问
* [默认可见性](#默认可见性)
* [谨慎构造函数](#谨慎构造函数)

## 信息泄漏

## 逻辑错误
* [Reentrancy攻击](#Reentrancy攻击)
* [Unchecked-Send漏洞](#Unchecked-Send漏洞)

## 拒绝服务
* [revert类型拒绝服务](#revert类型拒绝服务)
* [死循环类型拒绝服务](#死循环类型拒绝服务)
## 函数误用
* [Bad Randomness - 可预测的随机处理](# 'Bad Randomness - 可预测的随机处理')
* [不期而至的Ether](#'不期而至的Ether')
* [Tx.Origin身份验证](Tx.Origin身份验证)
# 漏洞列表
## 溢出漏洞
### 整数溢出
#### 漏洞描述

以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着一个整型变量只能有一定范围的数字表示。A uint8例如，只能存储在范围[0,255]的数字。试图存储256到一个uint8将导致0。如果不注意，如果不选中用户输入并执行计算，导致数字超出存储它们的数据类型的范围，则可以利用Solidity中的变量。

当执行操作需要固定大小的变量来存储超出变量数据类型范围的数字（或数据）时，会发生溢出。
#### 漏洞危害

可能导致合约失效、无限发币等风险。例如攻击者就可以利用这个漏洞，可无限制的将任意账户的代币token转到指定的账户(_to)，从而导致所有持有次代币的账户都有可能被盗取，严重危害了用户的财产安全。

#### 产生原理
  * 上溢错误
  
  	数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
	+0x000000000000000000000000000000000001  
	=0x000000000000000000000000000000000000
	数字增长超过其最大值时发生溢出。 好比声明一个uint8变量（8位的无符号变量）。 意思是，变量的数值范围0	  到28-1（255）。
	看下边：
    uint 8 a = 255;
    a++;
	发生溢出，因为a的最大值是255。
	Solidity最大能处理256位数字，最大值为2**256-1，加1会导致归 0，发生溢出：

	0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  
	+0x000000000000000000000000000000000001  
    =0x000000000000000000000000000000000000
    
  * 下溢错误
  	
    好了，看看另个极端，也就是下溢错误。Over跟under是反义词。这俩错误也是反着来的。
	uint8只能取0到255之间的值，还记得吧？ 那么，考虑以下代码。
	unint8 a = 0;
	a–;
	这就是下溢，后果是a的最大可能值是255。
	出现在Solidity智能合约中，就是这：  
	0x000000000000000000000000000000000000  
	–0x000000000000000000000000000000000001  
	=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

* 案例分析 BEC智能合约致命漏洞
  * 安全事件
  
	最近，智能合约漏洞很火。让我们再来看一下4月22日BeautyChain（BEC）的智能合约中一个毁灭性的漏洞。BeautyChain团队宣布，BEC代币在4月22日出现异常。攻击者通过智能合约漏洞成功转账了10^58 BEC到两个指	 定的地址。
    
	具体交易详情[https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f](https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f)
	攻击者到底是怎么攻击的？为什么能转账这么大的BEC？
    
  * 智能合约代码
  
	首先我们来看BEC转账的智能合约代码
    
    ```Solidity
    
    function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
        uint cnt = _receivers.length;
        uint256 amount = uint256(cnt) * _value;
        require(cnt > 0 && cnt <= 20);
        require(_value > 0 && balances[msg.sender] >= amount);
     
        balances[msg.sender] = balances[msg.sender].sub(amount);
        for (uint i = 0; i < cnt; i++) {
            balances[_receivers[i]] = balances[_receivers[i]].add(_value);
            Transfer(msg.sender, _receivers[i], _value);
        }
        return true;
     }
    
    ```
    
    以上的代码是Solidity语言，是一门面向合约的，为实现智能合约而创建的高级编程语言。
    
  * 代码解读
  
	知道了这几个变量类型，下面我们一行一行的来读这段代码。
    
	第一行
    
	function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused 		returns (bool)
	函数有两个参数:
    _receivers —————转账接收人，address类型的变量数组，是一个160位的值。
    _value ———————-转账数量，uint256的状态变量，256位的无符号整数。
    定义函数batchTransfer，功能主要是实现转账，接收两个参数，定义了参数的取值范围。
    
    第二行
    
    uint cnt = _receivers.length;
    计算接收人地址对应地址数组的长度，即转账给多少人。
    
    第三行
    
    uint256 amount = uint256(cnt) * _value;
    把unit类型的cnt参数值强制转换为uint256然后乘以转账数量_value 并赋值给uint256类型的amount变量。
    
    第四行
    
    require(cnt > 0 && cnt <= 20);
    require函数
    require的入参判定为 false，则终止函数，恢复所有对状态和以太币账户的变动，并且也不会消耗 gas 。 判	  断cnt是否大于0且cnt是否小于等于20
    
    第五行
    
    require(_value > 0 && balances[msg.sender] >= amount);
    
    参数解读:
    _value—————————————转账数量
    balances[msg.sender]————-转账人余额
    amount————————————转账总数量
    判断_value是否大于0且转账人的余额balances[msg.sender]大于等于转账总金额amount

    第六行

    balances[msg.sender] = balances[msg.sender].sub(amount);
    计算转账人的余额，使用当前余额balances[msg.sender]减去转账总数量

    第七行

    for (uint i = 0; i < cnt; i++) {
    这里是一个循环，循环次数为cnt（遍历转账地址）

    第八行

    balances[_receivers[i]] = balances[_receivers[i]].add(_value);
    当i有具体的值时，balances[_receivers[i]]表示转账接收人，这里是表示转账人给转账接收人_value数量的币。

    第九行

    Transfer(msg.sender, _receivers[i], _value);
    保存转账记录

    第十行

    return true;
    函数返回为True
    
  * 代码流程
    
    OK，我们读了完整的代码，接下来请看一个流程图

  * 攻击过程

	其实，他只是细心了一点，所使用的攻击方法并不高明啊，你且听我慢慢道来，注意看，别走神啊。
    
  * 交易详情
  
	我们首先看这笔详细的交易：
    
    我们从图可以看到转账接收人有两个地址，即balances[_receivers]:
    000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033
    0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7
    转账数量为_value:
    8000000000000000000000000000000000000000000000000000000000000000（十六进制）
    转10进制为
    57896044618658097711785492504343953926634992332820282019728792003956564819968
    OK，接下来我们来走函数流程

    第一行

    function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool)

    正常执行

    第二行

    uint cnt = _receivers.length
    由于这里有两个转账接收人地址，address数组长度为2，所以cnt为2，类型为uint

    第三行

    uint256 amount = uint256(cnt) * _value;   
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968
    cnt=2
    两者相乘得到amount，类型为uint256
    即amount=115792089237316195423570985008687907853269984665640564039457584007913129639936
    考试重点用上了，记不住的同学去前面看看。
    amount的类型为uint256，那么按照理论，它的最大取值是0到2^256减1，即
    115792089237316195423570985008687907853269984665640564039457584007913129639935
    所以amount瞬间从115792089237316195423570985008687907853269984665640564039457584007913129639936变成了0
    第三行得到的结果：amount=0

    第四行

    require(cnt > 0 && cnt <= 20);
    cnt=2，2肯定大于0，2当然也小于等于20
    所以这个条件成立，require函数返回值为True。

    第五行

    require(_value > 0 && balances[msg.sender] >= amount);
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968
    _value肯定是大于0，转账人的余额balances[msg.sender]肯定是大于等于0的。
    所以这个条件同样成立，require函数返回值为True。

    第六行

    balances[msg.sender] = balances[msg.sender].sub(amount); 前面的条件都成立，那么代码会执行到这。
    这行代码是求转账人转完账以后剩下的余额，amount为0 ，那么转账人的余额其实没变！！！
    
    第七行

    for (uint i = 0; i < cnt; i++)
    cnt=2，该行代码表示执行两次后面的操作

    第八行
    
    balances[_receivers[i]] = balances[_receivers[i]].add(_value);  
    i=0时，转账接收人balances[_receivers[0]]的余额加_value
    i=1时，转账接收人balances[_receivers[1]]的余额加_value
    看到这里其实我们就很明白了吧。

    攻击者给以下两个转账接收人
        000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033
        0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7
    转了
    _value=57896044618658097711785492504343953926634992332820282019728792003956564819968个币

    更可恶的是，攻击者执行完这个操作，转账人的余额根本没变，看代码第六行的执行结果。

    第九行

    Transfer(msg.sender, _receivers[i], _value);
    这里只是把上面两个转账记录保存。

    第十行

    return true;
    函数返回为True
    
    参考链接：[https://blog.csdn.net/Fly_hps/article/details/80732159](https://blog.csdn.net/Fly_hps/article/details/80732159)

#### 修复方案
  
为了避免整数溢出，可以将条件判断改为比较操作，例如：require(balances[msg.sender] > _amount)，这样就不会执行算术操作进行进行逻辑判断，一定程度上避免了整数溢出的发生。

为了防止整数溢出的发生，一方面可以在算术逻辑前后进行验证，另一方面可以直接使用 OpenZeppelin 维护的一套智能合约函数库中的 SafeMath 来处理算术逻辑。[OppenZepplin](https://github.com/OpenZeppelin/zeppelin-solidity) 在构建和审计 Ethereum 社区可以利用的安全库方面做得非常出色。特别是，他们的 [SafeMath](https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol) 是一个用来避免上溢/下溢漏洞的参考或库。
```solidity
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b); 
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b; 
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
```

## 越权访问
### 默认可见性
#### 漏洞描述

 Solidity 中的函数具有可见性说明符，它们会指定我们可以如何调用函数。可见性决定一个函数是否可以由用户或其他派生契约在外部调用、只允许内部调用或只允许外部调用。有四个可见性说明符，详情请参阅 [Solidity 文档](http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters)。为允许用户从外部调用函数，函数的可见性默认为 ` public `。

#### 漏洞危害

正如本节将要讨论的，可见性说明符的不正确使用可能会导致智能合约中的一些资金流失。

#### 产生原理

函数的可见性默认是 ` public `。因此，不指定任何可见性的函数就可以由用户在外部调用。当开发人员错误地忽略应该是私有的功能（或只能在合约本身内调用）的可见性说明符时，问题就出现了。
让我们快速浏览一个简单的例子。

```solidity
contract HashForEther {
    
    function withdrawWinnings() {
        // Winner if the last 8 hex characters of the address are 0. 
        require(uint32(msg.sender) == 0);
        _sendWinnings();
     }
     
     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}
```

这个简单的合约被设计为充当赏金猜测游戏的地址。要赢得该合约的余额，用户必须生成一个以太坊地址，其最后 8 个十六进制字符为0。一旦获得，他们可以调用 ` WithdrawWinnings() ` 函数来获得赏金。
不幸的是，这些功能的可见性没有得到指定。特别是，因为 ` _sendWinnings() ` 函数的可见性是 ` public `，任何地址都可以调用该函数来窃取赏金。

#### 案例分析 Parity MultiSig Wallet（First Hack）

在 Parity 多签名钱包遭受的第一次黑客攻击中，约值 3100 万美元的 Ether 被盗，主要是三个钱包。Haseeb Qureshi 在[这篇文章](https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce)中给出了一个很好的回顾。

实质上，这些多签名钱包（可以在[这里](https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol)找到）是从一个基础的 ` Wallet ` 合约构建出来的，该基础合约调用包含核心功能的库合约（如[真实世界中的例子：Parity Multisig（Second Hack）](#真实世界示例parity-multisig-walletsecond-hack)中所述)。库合约包含初始化钱包的代码，如以下代码片段所示

```solidity
contract WalletLibrary is WalletEvents {
  
  ... 
  
  // METHODS

  ...
  
  // constructor is given number of sigs required to do protected "onlymanyowners" transactions
  // as well as the selection of addresses capable of confirming them.
  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  ...

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}
```

请注意，这两个函数都没有明确指定可见性。两个函数的可见性都默认为 ` public ` 。钱包构造函数会调用 ` initWallet() ` 函数，并设置多签名钱包的所有者，如 ` initMultiowned() ` 函数中所示。由于这些函数意外地设置为 ` public `，攻击者可以在部署的合约上调用这些功能，并将所有权重置为攻击者地址。作为主人，袭击者随后取走钱包中所有的 Ether，损失高达 3100 万美元。

#### 修复方案

总是指定合约中所有功能的可见性、即便这些函数的可见性本就有意设计成 ` public `，这是一种很好的做法。最近版本的 Solidity 将在编译过程中为没有明确设置可见性的函数显示警告，以鼓励这种做法。

### 谨慎构造函数
#### 漏洞描述

构造函数是特殊函数，在初始化合约时经常执行关键的特权任务。在solidity v0.4.22构造函数被定义为与包含它们的合约名称相同的函数之前。因此，如果合约名称在开发过程中发生变化，如果构造函数名称没有更改，它将变成正常的可调用函数。


#### 漏洞危害

如果合约名称被修改，或者在构造函数名称中存在拼写错误以致它不再与合约名称匹配，则构造函数的行为将与普通函数类似。这可能会导致可怕的后果，特别是如果构造函数正在执行特权操作。


#### 产生原理

考虑以下合约：

```solidity
contract OwnerWallet {
    address public owner;

    //constructor
    function ownerWallet(address _owner) public {
        owner = _owner;
    }
    
    // fallback. Collect ether.
    function () payable {} 
    
    function withdraw() public {
        require(msg.sender == owner); 
        msg.sender.transfer(this.balance);
    }
}
```

该合约收集以太，并只允许所有者通过调用该withdraw()函数来撤销所有以太。这个问题是由于构造函数没有完全以合约名称命名的。具体来说，ownerWallet是不一样的OwnerWallet。因此，任何用户都可以调用该ownerWallet()函数，将自己设置为所有者，然后通过调用将合约中的所有内容都取出来withdraw()。

#### 案例分析 MorphToken智能合约构造函数大小写编码错误漏洞

[链接一](http://www.freebuf.com/vuls/175904.html)  
[链接二](https://bcsec.org/index/detail?id=157&tag=1)
* 漏洞描述

以太坊智能合约的含义就是一组代码（函数）和数据（合约的状态），它们位于以太坊区块链的一个特定地址上。智能合约一般使用solidity语言编写。
  
Morpheus Network与世界上一些大型航运、海关和银行公司协商，通过利用区块链的智能合约技术建立一个全面服务的、全球性的、自动化的、开放的供应链平台和一个集成的加密货币支付系统 ，发布基于以太坊的 MorphToken。
    
2018年6月22日，Morpheus Network 发公告称将发布新的智能合约，以更新目前含有漏洞的合约代码。新的Token名称为MRPH，新旧Token以1:1兑换。
    
随后，知道创宇404区块链安全研究团队开始漏洞应急，通过分析MorphToken合约代码和交易历史，确定该漏洞是由于大小写编码问题，错误的将Owned合约的构造函数Owned的首字母小写，使之成为了一个普通函数owned，任何以太坊账户均可调用该函数夺取合约的所有权，进一步实现盗币等系列非法操作。随即我们发布了相关应急报告，同时我们也注意到BCSEC安全团队发布了相关的分析文档。
    
在后续的研究中，我们发现早在2017年8月29日，Github上就有人提到了这种因构造函数缺失导致的合约安全漏洞问题。该漏洞目前影响包括MorphToken、B2X、DoubleOrNothingImpl等多个智能合约。

* 漏洞原理

在MorphToken的合约代码里：[https://etherscan.io/address/0x2ef27bf41236bd859a95209e17a43fbd26851f92#code ](https://etherscan.io/address/0x2ef27bf41236bd859a95209e17a43fbd26851f92#code )可以明显的看到相关大小写编写错误：

```
    contract Owned {
        address public owner;

        function owned() public {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
        
        /* This function is used to transfer adminship to new owner
         * @param  _newOwner - address of new admin or owner        
         */

        function transferOwnership(address _newOwner) onlyOwner public {
            owner = _newOwner;
        }          
    }
```

以太坊智能合约中的构造函数主要用于初始化，如：确定合约的所有者，并且只会在合约部署时运行。在小于0.4.22版本的solidify编译器语法要求中，构造函数的名称应该和合约名称保持一致。如果程序员在编写合约时将构造函数名称写错，那么原本的构造函数将成为任何人都可以调用的普通函数。

#### 修复方案

这个问题已经在Solidity编译器的版本中得到了主要解决0.4.22。该版本引入了一个constructor指定构造函数的关键字，而不是要求函数的名称与契约名称匹配。建议使用此关键字来指定构造函数，以防止上面的命名问题。


## 信息泄漏


## 逻辑错误
### Reentrancy攻击
#### 漏洞描述

以太坊智能合约的特点之一是能够调用和利用其他外部合约的代码。合约通常也处理Ether，因此通常会将Ether发送给各种外部用户地址。调用外部合约或将以太网发送到地址的操作需要合约提交外部调用。这些外部调用可能被攻击者劫持，迫使合约执行进一步的代码（即通过回退函数），包括回调自身。因此代码执行“ 重新进入 ”合约。这种攻击被用于臭名昭着的DAO攻击。

有关重入攻击的进一步阅读，请参阅[对智能合约的重入式攻击](https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4)和 [Consensus - 以太坊智能合约最佳实践](https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert)。

#### 漏洞危害

当合约将 Ether 发送到未知地址时，可能会发生此攻击。攻击者可以在 [Fallback 函数](https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function)中的外部地址处构建一个包含恶意代码的合约。因此，当合约向此地址发送 Ether 时，它将调用恶意代码。通常，恶意代码会在易受攻击的合约上执行一个函数、该函数会运行一项开发人员不希望的操作。“重入”这个名称来源于外部恶意合约回复了易受攻击合约的功能，并在易受攻击的合约的任意位置“重新输入”了代码执行。

可能导致基于重入漏洞的恶意转账等风险。

#### 产生原理

智能合约转账以太币：  
address x = 0x123;  
address myAddress = this;  
if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);  
智能合约还可以通过x.call.value()()、x.send()方式转账。他们的区别在于：  
<address\>.transfer()</address\>    
    当发送失败时会 throw; 回滚状态  
    只会传递 2300 Gas 供调用，防止重入（reentrancy）  
<address\>.send()</address\>  
    当发送失败时会返回 false 布尔值  
    只会传递 2300 Gas 供调用，防止重入（reentrancy）  
<address\>.gas().call.value()()</address\>  
    当发送失败时会返回 false 布尔值  
   	传递所有可用 Gas 进行调用（可通过 gas(gas_value) 进行限制），不能有效防止重入（reentrancy）
如果如果x是合约地址，x合约的回退函数（fallback 函数）会随transfer、send、call调用一起执行（这个是EVM特性）。x合约必须必须显示的实现回退函数，例如function () payable{}。  
下面用具体代码例子分析：
该合约充当以太坊保险库，允许存款人每周只提取1个Ether：

```
contract EtherStore {
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    
    }

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
    // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
    // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    
    }

}
```

该合约有两个公共职能。depositFunds()和withdrawFunds()。该depositFunds()功能只是增加发件人余额。该withdrawFunds()功能允许发件人指定要撤回的wei的数量。如果所要求的退出金额小于1Ether并且在上周没有发生撤回，它才会成功。还是呢？...	
该漏洞出现在[17]行，我们向用户发送他们所要求的以太数量。考虑一个恶意攻击者创建下列合约：

```
contract Attack {
    EtherStore public etherStore;
        // intialise the etherStore variable with the contract address
        constructor(address _etherStoreAddress) {
        etherStore = EtherStore(_etherStoreAddress);
    }
    
    function pwnEtherStore() public payable {
        // attack to the nearest ether
        require(msg.value >= 1 ether);
        // send eth to the depositFunds() function
        etherStore.depositFunds.value(1 ether)();
        // start the magic
        etherStore.withdrawFunds(1 ether);
    }
    
    function collectEther() public {
    msg.sender.transfer(this.balance);
    }
    // fallback function - where the magic happens
    
    function () payable {
        if (etherStore.balance > 1 ether) {
        etherStore.withdrawFunds(1 ether);
        }
    }
}
```

让我们看看这个恶意合约是如何利用我们的EtherStore合约的。攻击者可以0x0...123使用EtherStore合约地址作为构造函数参数来创建上述合约（假设在地址中）。这将初始化并将公共变量etherStore指向我们想要攻击的合约。
然后攻击者会调用这个pwnEtherStore()函数，并且有一些以太（大于或等于1），1 ether这个例子可以说。在这个例子中，我们假设一些其他用户已经将以太币存入这份合约中，这样它的当前余额就是10 ether。然后会发生以下情况：	
1. Attack.sol -Line[15] -的depositFunds()所述EtherStore合约的功能将与被叫msg.value的1 ether（和大量gas）。sender（msg.sender）将是我们的恶意合约（0x0...123）。因此，balances[0x0..123] = 1 ether。
2. Attack.sol - Line [17] - 恶意合约将使用一个参数来调用合约的withdrawFunds()功能。这将通过所有要求（合约的行[12] - [16] ），因为我们以前没有提款。
3. EtherStore.sol - 行[17] - 合约将发送1 ether回恶意合约。
4. Attack.sol - Line [25] - 发送给恶意合约的以太网将执行后备功能。
5. Attack.sol - Line [26] - EtherStore合约的总余额是10 ether，现在9 ether是这样，如果声明通过。
6. Attack.sol - Line [27] - 回退函数然后EtherStore withdrawFunds()再次调用该函数并“ 重新输入 ” EtherStore合约。
7. EtherStore.sol - 行[11] - 在第二次调用时withdrawFunds()，我们的余额仍然1 ether是行[18]尚未执行。因此，我们仍然有balances[0x0..123] = 1 ether。lastWithdrawTime变量也是这种情况。我们再次通过所有要求。
8. EtherStore.sol - 行[17] - 我们撤回另一个1 ether。
9. 步骤4-8将重复 - 直到EtherStore.balance >= 1[26]行所指定的Attack.sol。
10. Attack.sol - Line [26] - 一旦在EtherStore合约中留下少于1（或更少）的ether，此if语句将失败。这样就EtherStore可以执行合约的[18]和[19]行（每次调用withdrawFunds()函数）。
11. EtherStore.sol - 行[18]和[19] - balances和lastWithdrawTime映射将被设置并且执行将结束。
最终的结果是，攻击者已经从EtherStore合约中立即撤销了所有（第1条）金额，只需一笔交易即可。


#### 案例分析 Dao安全事件

在DAO源码中，有withdrawRewardFor函数：

```
    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {
      if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])
        throw;
      uint reward =
        (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
      if (!rewardAccount.payOut(_account, reward)) //vulnerable
        throw;
      paidOut[_account] += reward;
      return true;
    }
    
	这里调用了payOut函数进行付款。
    
    function payOut(address _recipient, uint _amount) returns (bool) {
      if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))
          throw;
      if (_recipient.call.value(_amount)()) { //vulnerable
          PayOut(_recipient, _amount);
          return true;
      } else {
          return false;
    }
```

而payOut中直接使用的是message call的方式发送以太币，从而导致了重入漏洞。



#### 修复方案

有许多常用技术可以帮助避免智能合约中潜在的重入漏洞。  

首先是（在可能的情况下）在将 Ether 发送给外部合约时使用内置的 [transfer() 函数](http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related)。转账功能只发送 ` 2300 gas ` 不足以使目的地址/合约调用另一份合约（即重入发送合约）。

第二种技术是确保所有改变状态变量的逻辑发生在 Ether 被发送出合约（或任何外部调用）之前。在这个 EtherStore 例子中，EtherStore.sol - 行[18]和行[19] 应放在 行[17] 之前。将任何对未知地址执行外部调用的代码，放置在本地化函数或代码执行中作为最后一个操作，是一种很好的做法。这被称为[检查效果交互（checks-effects-interactions）](http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern)模式。

第三种技术是引入互斥锁。也就是说，要添加一个在代码执行过程中锁定合约的状态变量，阻止重入调用。

给 EtherStore.sol 应用所有这些技术（同时使用全部三种技术是没必要的，只是为了演示目的而已）会出现如下的防重入合约：

```solidity
contract EtherStore {

    // initialise the mutex
    bool reEntrancyMutex = false;
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(!reEntrancyMutex);
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
        // set the reEntrancy mutex before the external call
        reEntrancyMutex = true;
        msg.sender.transfer(_weiToWithdraw);
        // release the mutex after the external call
        reEntrancyMutex = false; 
    }
 }
```
### Unchecked-Send漏洞

参考文档：[http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/](http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/)

#### 漏洞描述

Solidity 中有很多方法可以执行外部调用。向外部账户发送 Ether 通常通过 transfer() 方法完成。不过，也可以使用 send() 功能，而且，对于更多功能的外部调用，在 Solidity 中可以直接使用 CALL 操作码。 call() 和 send() 函数会返回一个布尔值，显示调用是成功还是失败。因此，这些功能有一个简单的警告作用，如果（由 call() 或 send() 初始化的）外部调用失败，执行这些函数的交易将不会回滚，反而 call() 或 send() 将简单地返回 false 。


#### 漏洞危害

当没有检查返回值时，会出现一个常见的错误，并不是开发人员希望的那样发生回滚。


#### 产生原理


考虑下面的例子：

```solidity
contract Lotto {

    bool public payedOut = false;
    address public winner;
    uint public winAmount;
    
    // ... extra functionality here 

    function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
    
    function withdrawLeftOver() public {
        require(payedOut);
        msg.sender.send(this.balance);
    }
}
```

这份合约代表了一个类似于大乐透的合约，在这种合约中，winner收到winAmount了ether，通常只剩下一点让任何人退出。

该错误存在于第[11]行，其中使用send()而不检查响应。在这个微不足道的例子中，可以将winner其事务失败（无论是通过耗尽gas、故意抛出回退函数还是通过调用堆栈深度攻击的合约）payedOut设置为true（无论是否发送了以太币） 。在这种情况下，公众可以winner通过该withdrawLeftOver()功能撤回奖金。

#### 案例分析

[Etherpot](https://github.com/etherpot)是一个彩票智能合约，与上面提到的示例合约不太相似。Etherpot 的 Soloidity 代码可以在这里找到：[lotto.sol](https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol)。这个合约的主要缺点是对块哈希的不当使用（只有最后 256 个块的哈希值是可用的，请参阅 Aakil Fernandes 关于 Etherpot 如何正确实现的[帖子](http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks)。然而，这份合约也受到未经检查的 Call 返回值的影响。

注意lotto.sol 的 行[80] 上的函数 cash() ：
```
	function cash(uint roundIndex, uint subpotIndex){
        var subpotsCount = getSubpotsCount(roundIndex);
        if(subpotIndex>=subpotsCount)
            return;
        var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);
        if(decisionBlockNumber>block.number)
            return;
        if(rounds[roundIndex].isCashed[subpotIndex])
            return;
        //Subpots can only be cashed once. This is to prevent double payouts
        var winner = calculateWinner(roundIndex,subpotIndex);    
        var subpot = getSubpot(roundIndex);
        winner.send(subpot);
        rounds[roundIndex].isCashed[subpotIndex] = true;
        //Mark the round as cashed
}
```

请注意，在[21]行，发送函数的返回值没有被检查，然后下一行设置了一个布尔值，表示已经向赢家发送了属于他们的奖金。这个错误可能引发一种状态，即赢家没有收到他们的 Ether，但是合约状态表明赢家已经得到了支付。
这个错误的更严重的版本发生在[King of the Ether](https://www.kingoftheether.com/thrones/kingoftheether/index.html)。已经有人写出一篇优秀的安全检验报告，详细介绍了一个未经检查的send()失败交易可以如何用于攻击合约。


#### 修复方案

只要有可能，使用 transfer() 功能，而不是 send() ，因为，如果外部交易回滚， transfer() 会触发回滚。如果需要使用 send() ，请务必检查返回值。

如果实在是需要使用send()，检查send()返回值是否转账成功，成功后再做其他操作：
```
function sendToWinner() public {
	require(!payedOut);
	if(winner.send(winAmount)){
		payedOut = true;
	}else{throw;}
    	}
```

## 拒绝服务


### revert类型拒绝服务

#### 漏洞描述

DoS 无处不在，在 Solidity 里也是，与其说是拒绝服务漏洞不如简单的说成是“不可恢复的恶意操作或者可控制的无限资源消耗”。可能导致无限循环、递归栈耗尽等拒绝服务风险。

#### 漏洞危害

简单的说就是对以太坊合约进行 DoS 攻击，可能导致 Ether 和 Gas 的大量消耗，更严重的是让原本的合约代码逻辑无法正常运行。


#### 产生原理

下面一个例子（代码改自 DASP 中例子）：

```
pragma solidity ^0.4.10;

contract PresidentOfCountry {
    address public president;
    uint256 price;

    function PresidentOfCountry(uint256 _price) {
        require(_price > 0);
        price = _price;
        president = msg.sender;
    }

    function becomePresident() payable {
        require(msg.value >= price); // must pay the price to become president
        president.transfer(price);   // we pay the previous president
        president = msg.sender;      // we crown the new president
        price = price * 2;           // we double the price to become president
    }
}
```

一个简单的类似于 KingOfEther 的合约，按合约的正常逻辑任何出价高于合约当前 price 的都能成为新的president，原有合约里的存款会返还给上一人 president，并且这里也使用了 transfer()来进行Ether转账，看似没有问题的逻辑，但不要忘了，以太坊中有两类账户类型，如果发起becomePresident() 调用的是个合约账户，并且成功获取了 president，如果其 fallback() 函数恶意进行了类似 revert() 这样主动跑出错误的操作，那么其他账户也就无法再正常进行 becomePresident 逻辑成为president了。

简单的攻击代码如下：
```
contract Attack {
    function () { revert(); }

    function Attack(address _target) payable {
        _target.call.value(msg.value)(bytes4(keccak256("becomePresident()")));
    }
}
```

#### 案例分析



#### 修复方案

### 死循环类型拒绝服务
#### 漏洞描述

#### 漏洞危害

#### 产生原理

#### 案例分析

#### 修复方案
## 函数误用
### Bad Randomness – 可预测的随机处理
#### 漏洞描述

伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。

#### 漏洞危害

如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行“作弊”。


#### 产生原理

摘自 DASP 的代码块：

```
uint256 private seed;
function play() public payable {
    require(msg.value >= 1 ether);
    iteration++;
    uint randomNumber = uint(keccak256(seed + iteration));
    if (randomNumber % 2 == 0) {
        msg.sender.transfer(this.balance);
    }
}
```

这里 seed 变量被标记为了私有变量，前面有说过链上的数据都是公开的，seed 的值可以通过扫描与该合约相关的 TX 来获得。获取 seed 值后，同样的 iteration 值也是可以得到的，那么整个 uint(keccak256(seed + iteration)) 的值就是可预测的了。

就 DASP 里面提到的，还有一些合约喜欢用 block.blockhash(uint blockNumber) returns (bytes32) 来获取一个随机哈希，但是这里切记不能使用 block.number 也就是当前块号来作为 blockNumber 的值，因为在官方文档中明确写了：
block.blockhash(uint blockNumber) returns (bytes32): hash of the given block – only works for 256 most recent blocks excluding current

意思是说 block.blockhash() 只能使用近 256 个块的块号来获取 Hash 值，并且还强调了不包含当前块，如果使用当前块进行计算 block.blockhash(block.numbber) 其结果始终为 0x0000000.....：



同样的也不能使用 block.timestamp, now 这些可以由矿工控制的值来获取随机数。


#### 案例分析

暂时还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

一切链上的数据都是公开的，想要获取一个靠谱的随机数，使用链上的数据看来是比较难做到的了，这里有一个独立的项目 Oraclize 被设计来让 Smart Contract 与互联网进行交互，有兴趣的同学可以深入了解一下。（附上基于 Oraclize 的随机数获取方法 [randomExample](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)）

参考链接：
- [https://github.com/oraclize/ethereum-api](https://github.com/oraclize/ethereum-api)
- [https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol](https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)

### 不期而至的Ether
#### 漏洞描述

通常，当 Ether 发送到合约时，它必须执行回退功能或合约中描述的其他功能。这里有两个例外，合约可能会收到了 Ether 但并不会执行任何函数。通过收到以太币来触发代码的合约，对强制将以太币发送到某个合约这类攻击是非常脆弱的。

关于这方面的进一步阅读，请参阅[如何保护您的智能合约：6](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834) 和 [Solidity security patterns - forcing ether to a contract](http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html)

一种常用的防御性编程技术对于执行正确的状态转换或验证操作很有用，它是不变量检查（Invariant-checking）。该技术涉及定义一组不变量（不应改变的度量或参数），并且在单个（或多个）操作之后检查这些不变量保持不变。这基本上是很好的设计，保证受到检查的不变量在实际上保持不变。不变量的一个例子是发行量固定的 [ERC20](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md) 代币合约的 ` totalSupply ` 。不应该有函数能修改此不变量，因此可以在该 ` transfer() ` 函数中添加一个检查以确保 ` totalSupply ` 保持未修改状态，确保函数按预期工作。

不管智能合约中规定的规则如何，有一个量，特别容易诱导开发人员将其当作明显的“不变量”来使用，但它在事实上是可以由外部用户来操纵的，那便是合约中存储的 Ether 数量。通常，开发人员刚开始学习 Solidity 时，他们有一种误解，认为合约只能通过 ` payable ` 函数接受或获得 Ether。这种误解可能会导致合约对其内部的 ETH 余额有错误的假设，进而导致一系列的漏洞。此漏洞的明显信号是（不正确地）使用 ` this.balance ` 。正如我们将看到的，错误地使用 ` this.balance ` 会导致这种类型的严重漏洞。

有两种方式可以将 Ether（强制）发送给合约，而无需使用 ` payable ` 函数或执行合约中的任何代码。这些在下面列出。

**自毁**

任何合约都能够实现该 [` selfdestruct(address) `](http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct) 功能，该功能从合约地址中删除所有字节码，并将所有存储在那里的 Ether 发送到参数指定的地址。如果此指定的地址也是合约，则不会调用任何功能（包括故障预置）。因此，使用 ` selfdestruct() ` 函数可以无视目标合约中存在的任何代码，强制将 Ether 发送给任一目标合约，包括没有任何可支付函数的合约。这意味着，任何攻击者都可以创建带有 ` selfdestruct() ` 函数的合约，向其发送 Ether，调用 ` selfdestruct(target) ` 并强制将 Ether 发送至 ` target ` 合约。Martin Swende 有一篇出色的[博客文章](http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html)描述了自毁操作码（Quirk＃2）的一些诡异操作，并描述了客户端节点如何检查不正确的不变量，这可能会导致相当灾难性的客户端问题。

**预先发送的 Ether**

合约不使用 ` selfdestruct() ` 函数或调用任何 payable 函数仍可以接收到 Ether 的第二种方式是把 Ether 预装进合约地址。合约地址是确定性的，实际上地址是根据创建合约的地址及创建合约的交易 Nonce 的哈希值计算得出的，即下述形式： ` address = sha3(rlp.encode([account_address,transaction_nonce]) ` 请参阅 [Keyless Ether](https://github.com/sigp/solidity-security-blog#keyless-eth) 在这一点上的一些有趣用例）。这意味着，任何人都可以在创建合约之前计算出合约地址，并将 Ether 发送到该地址。当合约确实创建时，它将具有非零的 Ether 余额。

#### 漏洞危害

造成不可预估的后果，可能会导致合约无法正常执行，也可以会导致超额转账等一些未知结果到漏洞。

#### 产生原理

根据上述知识，我们来探讨一些可能出现的缺陷。
考虑过于简单的合约，

EtherGame.sol：

```solidity
contract EtherGame {
    
    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 
    
    mapping(address => uint) redeemableEther;
    // users pay 0.5 ether. At specific milestones, credit their accounts
    function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }
    
    function claimReward() public {
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }    
```

这个合约代表一个简单的游戏（自然会引起[条件竞争（Race-conditions）](#条件竞争非法预先交易)），玩家可以将 ` 0.5 ether ` 发送给合约，希望成为第一个达到三个里程碑之一的玩家。里程碑以 Ether 计价。当游戏结束时，第一个达到里程碑的人可以获得合约的部分 Ether。当达到最后的里程碑（10 Ether）时，游戏结束，用户可以申请奖励。

EtherGame 合约的问题出自在 [14] 行（以及相关的 [16] 行）和 [32] 行中对 ` this.balance ` 的错误使用。一个调皮的攻击者可以通过（上面讨论过的） ` selfdestruct() ` 函数强行发送少量的以太，比如 ` 0.1 ether `，以防止未来的玩家达到一个里程碑。由于所有合法玩家只能发送 ` 0.5 ether ` 增量，而合约收到了 ` 0.1 ether ` ，合约的 ` this.balance ` 不再是半个整数。这会阻止 [18]、[21]和[24] 行的所有条件成立。

更糟糕的是，一个因错过了里程碑而复仇心切的攻击者可能会强行发送 ` 10 ether ` （或者会将合约的余额推到高出 ` finalMileStone ` 的数量），这将永久锁定合约中的所有奖励。这是因为 ` claimReward() ` 函数总是会回弹，因为 [32] 行中的要求（即 ` this.balance ` 大于 ` finalMileStone ` ）。

#### 案例分析

还没有找到该漏洞在真实世界中被利用的例子。然而，在 [Underhanded Solidity 竞赛](https://github.com/Arachnid/uscc/tree/master/submissions-2017/)中出现了一些可利用该漏洞的合约的例子。

#### 修复方案

这个漏洞通常是由于错误运用 ` this.balance ` 而产生的。如果可能，合约逻辑应该避免依赖于合约余额的确切值，因为它可以被人为地操纵。如果应用基于 ` this.balance ` 函数的逻辑语句，请确保考虑到了飞来横 Ether。

如果需要存储 Ether 的确定值，则应使用自定义变量来获得通过可支付函数获得的增量，以安全地追踪储存 Ether 的值。这个变量不应受到通过调用 ` selfdestruct() ` 强制发送的 Ether 的影响。

考虑到这一点，修正后的EtherGame合约版本可能如下所示：

```solidity
contract EtherGame {
    
    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 
    uint public depositedWei;
    
    mapping (address => uint) redeemableEther;
    
    function play() public payable {
        require(msg.value == 0.5 ether);
        uint currentBalance = depositedWei + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        depositedWei += msg.value;
        return;
    }
    
    function claimReward() public {
        // ensure the game is complete
        require(depositedWei == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }    
```

在这里，我们刚刚创建了一个新变量， ` depositedEther `，它跟踪已知的 Ether 存储量，并且这也是我们执行需求和测试时用到的变量。请注意，我们不再参考 ` this.balance `。

### Tx.Origin身份验证
#### 漏洞描述

Solidity具有一个全局变量，tx.origin它遍历整个调用栈并返回最初发送调用（或事务）的帐户的地址。在智能合约中使用此变量进行身份验证会使合约容易受到类似网络钓鱼的攻击。
有关进一步阅读，请参阅Stack Exchange Question，Peter Venesses博客和Solidity - Tx.Origin攻击。

#### 漏洞危害


授权用户使用该tx.origin变量的合约通常容易受到网络钓鱼攻击的攻击，这可能会诱使用户对易受攻击的合约执行身份验证操作。

#### 产生原理

考虑简单的合约，

```solidity
contract Phishable {
    address public owner;
    
    constructor (address _owner) {
        owner = _owner; 
    }
    
    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        require(tx.origin == owner);
        _recipient.transfer(this.balance); 
    }
}
```

请注意，在[11]行中，此合约授权withdrawAll()使用该功能tx.origin。该合约允许攻击者创建表单的攻击合约，

```solidity
import "Phishable.sol";

contract AttackContract { 
    
    Phishable phishableContract; 
    address attacker; // The attackers address to receive funds.

    constructor (Phishable _phishableContract, address _attackerAddress) { 
        phishableContract = _phishableContract; 
        attacker = _attackerAddress;
    }
    
    function () { 
        phishableContract.withdrawAll(attacker); 
    }
}
```

为了利用这个合约，攻击者会部署它，然后说服Phishable合约的所有者发送一定数量的合约。攻击者可能把这个合约伪装成他们自己的私人地址，社工受害人发送某种形式的交易到地址。受害者除非注意，否则可能不会注意到攻击者地址上有代码，或者攻击者可能将其作为多重签名钱包或某些高级存储钱包传递。

在任何情况下，如果受害者向AttackContract地址发送了一个事务（有足够的天然气），它将调用fallback功能，后者又调用该参数withdrawAll()的Phishable合约功能attacker。这将导致所有资金从Phishable合约中撤回到attacker地址。这是因为，首先初始化呼叫的地址是受害者（即owner中的Phishable合约）。因此，tx.origin将等于owner和require所述的上线[11] Phishable合约会通过。

#### 案例分析

还没有找到该漏洞在真实世界中被利用的例子。

#### 修复方案

tx.origin不应该用于智能合约授权。这并不是说该tx.origin变量不应该被使用。它确实在智能合约中有一些合法用例。例如，如果有人想要拒绝外部合约调用当前合约，他们可以实现一个requirefrom require(tx.origin == msg.sender)。这可以防止用于调用当前合约的中间合约，将合约限制为常规无代码地址。


# 参考
* [参考文献/更多阅读列表](#参考文献更多阅读列表)

  - [Ethereum Wiki - Safety](https://github.com/ethereum/wiki/wiki/Safety)
  - [Solidity Docs - Security Considerations](solidity.readthedocs.io/en/latest/security-considerations.html)
  - [Consensus - Ethereum Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices)
  - [History of Ethereum Security Vulnerabilities, Hacks and Their Fixes](https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes)
  - [Decentralized Application Security Project (DASP) Top 10 of 2018](http://www.dasp.co/)
  - [A Survey of attacks on Ethereum Smart Contracts](https://eprint.iacr.org/2016/1007.pdf)
  - [Ethereum Smart Contract Security](https://medium.com/cryptronics/ethereum-smart-contract-security-73b0ede73fa8)
  - [Lessons Learnt from the Underhanded Solidity Contest](https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1)


